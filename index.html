<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEAT Creatures - Tag & Hide and Seek</title>
    <style>
        /* ===== VISUAL STYLING ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }

        /* Control panel styling */
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #333;
            z-index: 1000;
            min-width: 300px;
        }

        .control-group {
            margin-bottom: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            width: 80px;
            padding: 2px;
            background: #333;
            color: white;
            border: 1px solid #555;
        }

        button {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 3px;
        }

        button:hover {
            background: #555;
        }

        .stats {
            font-size: 11px;
            margin-top: 10px;
            color: #aaa;
        }

        /* Canvas styling */
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <!-- ===== CONTROL PANEL ===== -->
    <div class="controls">
        <h3>üß† NEAT Creatures Control Panel</h3>
        
        <!-- Population Settings -->
        <div class="control-group">
            <label>Population Size: <span id="popDisplay">50</span></label>
            <input type="range" id="populationSize" min="10" max="200" value="50">
        </div>

        <!-- Speed Controls -->
        <div class="control-group">
            <label>Simulation Speed: <span id="speedDisplay">1.0x</span></label>
            <input type="range" id="simSpeed" min="0.1" max="3.0" step="0.1" value="1.0">
        </div>

        <!-- Neural Network Parameters -->
        <div class="control-group">
            <label>Mutation Rate: <span id="mutationDisplay">0.1</span></label>
            <input type="range" id="mutationRate" min="0.01" max="0.5" step="0.01" value="0.1">
        </div>

        <!-- Game Mode -->
        <div class="control-group">
            <label>Game Mode:</label>
            <select id="gameMode" style="background: #333; color: white; border: 1px solid #555;">
                <option value="tag">Tag (Red chases Blue)</option>
                <option value="hideSeek">Hide & Seek (Blue hides from Red)</option>
                <option value="mixed">Mixed Behaviors</option>
            </select>
        </div>

        <!-- Environment -->
        <div class="control-group">
            <label>Grid Size: <span id="gridDisplay">30</span></label>
            <input type="range" id="gridSize" min="20" max="60" value="30">
        </div>

        <!-- NEW: Energy System Controls -->
        <div class="control-group">
            <label>Wall Density: <span id="wallDisplay">5%</span></label>
            <input type="range" id="wallDensity" min="0" max="15" value="5">
        </div>

        <div class="control-group">
            <label>Energy Decay: <span id="energyDecayDisplay">0.2</span></label>
            <input type="range" id="energyDecay" min="0.1" max="1.0" step="0.1" value="0.2">
        </div>

        <!-- Controls -->
        <div class="control-group">
            <button id="pauseBtn">‚è∏Ô∏è Pause</button>
            <button id="resetBtn">üîÑ Reset</button>
            <button id="evolveBtn">üß¨ Force Evolution</button>
        </div>

        <!-- Statistics -->
        <div class="stats">
            <div>Generation: <span id="generation">1</span></div>
            <div>Best Fitness: <span id="bestFitness">0</span></div>
            <div>Average Fitness: <span id="avgFitness">0</span></div>
            <div>Tags: <span id="tagCount">0</span></div>
            <div>Alive: <span id="aliveCount">0</span></div>
            <div>Eliminated: <span id="eliminatedCount">0</span></div>
        </div>
    </div>

    <!-- ===== GAME CANVAS ===== -->
    <canvas id="gameCanvas"></canvas>

    <script>
        /* ===============================
         * NEAT CREATURES SIMULATION
         * A modular neural network ecosystem
         * =============================== */

        // ===== CONFIGURATION PARAMETERS =====
        // These are the main tuning parameters you can easily modify
        const CONFIG = {
            // Visual settings
            CANVAS_WIDTH: window.innerWidth,
            CANVAS_HEIGHT: window.innerHeight,
            
            // Grid and creature settings
            GRID_SIZE: 30,              // Size of each grid cell
            POPULATION_SIZE: 50,        // Number of creatures
            
            // Neural network parameters
            INPUT_NODES: 8,             // What creatures can "see"
            HIDDEN_NODES: 6,            // Processing power
            OUTPUT_NODES: 4,            // Movement directions
            
            // Evolution parameters
            MUTATION_RATE: 0.1,         // How much creatures change between generations
            CROSSOVER_RATE: 0.7,       // How often parents combine traits
            ELITE_PERCENTAGE: 0.2,     // Top performers that survive unchanged
            
            // Game mechanics
            CREATURE_SPEED: 1,          // How fast creatures move
            VISION_RANGE: 3,            // How far creatures can see
            TAG_DISTANCE: 1,            // Distance needed to tag
            
            // Energy system
            STARTING_ENERGY: 100,       // Energy creatures start with
            ENERGY_DECAY: 0.2,          // Energy lost per frame
            ENERGY_MOVE_COST: 0.5,      // Extra energy cost for moving
            ENERGY_GAIN_SURVIVAL: 0.3,  // Energy gained for surviving (prey/hiders)
            ENERGY_GAIN_TAG: 20,        // Energy gained for successful tag
            
            // Elimination system
            MAX_TAGS_BEFORE_OUT: 3,     // How many times you can be tagged before elimination
            ENERGY_DEATH_THRESHOLD: 0, // Energy level that causes death
            
            // Environment
            WALL_DENSITY: 0.05,         // Percentage of grid filled with deadly walls
            WALL_KILL_ENERGY: 50,       // Energy lost when touching walls
            
            // Evolution timing
            GENERATION_LENGTH: 3000,    // Frames before evolution (longer for new mechanics)
            
            // Colors for different creature types
            COLORS: {
                HUNTER: '#ff4444',      // Red - aggressive/chaser
                PREY: '#4444ff',        // Blue - defensive/hider
                NEUTRAL: '#44ff44',     // Green - balanced
                WALL: '#666666'         // Gray - obstacles
            }
        };

        // ===== GLOBAL VARIABLES =====
        let canvas, ctx;
        let creatures = [];
        let walls = [];
        let generation = 1;
        let frameCount = 0;
        let isPaused = false;
        let gameMode = 'tag';
        let stats = {
            tags: 0,
            bestFitness: 0,
            avgFitness: 0,
            aliveCount: 0,
            eliminatedCount: 0
        };

        // ===== NEURAL NETWORK CLASS =====
        // This represents the "brain" of each creature
        class NeuralNetwork {
            constructor() {
                // Initialize random weights for connections between nodes
                // Input layer to hidden layer connections
                this.inputToHidden = this.createMatrix(CONFIG.INPUT_NODES, CONFIG.HIDDEN_NODES);
                
                // Hidden layer to output layer connections
                this.hiddenToOutput = this.createMatrix(CONFIG.HIDDEN_NODES, CONFIG.OUTPUT_NODES);
                
                // Bias values (help with decision making)
                this.hiddenBias = this.createArray(CONFIG.HIDDEN_NODES);
                this.outputBias = this.createArray(CONFIG.OUTPUT_NODES);
                
                // Initialize with random values
                this.randomize();
            }

            // Create a matrix filled with zeros
            createMatrix(rows, cols) {
                let matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = new Array(cols).fill(0);
                }
                return matrix;
            }

            // Create an array filled with zeros
            createArray(size) {
                return new Array(size).fill(0);
            }

            // Fill all weights with random values between -1 and 1
            randomize() {
                // Randomize input to hidden connections
                for (let i = 0; i < this.inputToHidden.length; i++) {
                    for (let j = 0; j < this.inputToHidden[i].length; j++) {
                        this.inputToHidden[i][j] = (Math.random() * 2) - 1;
                    }
                }

                // Randomize hidden to output connections
                for (let i = 0; i < this.hiddenToOutput.length; i++) {
                    for (let j = 0; j < this.hiddenToOutput[i].length; j++) {
                        this.hiddenToOutput[i][j] = (Math.random() * 2) - 1;
                    }
                }

                // Randomize biases
                for (let i = 0; i < this.hiddenBias.length; i++) {
                    this.hiddenBias[i] = (Math.random() * 2) - 1;
                }
                for (let i = 0; i < this.outputBias.length; i++) {
                    this.outputBias[i] = (Math.random() * 2) - 1;
                }
            }

            // Process inputs through the network to get outputs
            feedForward(inputs) {
                // Calculate hidden layer values
                let hidden = [];
                for (let i = 0; i < CONFIG.HIDDEN_NODES; i++) {
                    let sum = this.hiddenBias[i];
                    for (let j = 0; j < CONFIG.INPUT_NODES; j++) {
                        sum += inputs[j] * this.inputToHidden[j][i];
                    }
                    hidden[i] = this.activate(sum); // Apply activation function
                }

                // Calculate output layer values
                let outputs = [];
                for (let i = 0; i < CONFIG.OUTPUT_NODES; i++) {
                    let sum = this.outputBias[i];
                    for (let j = 0; j < CONFIG.HIDDEN_NODES; j++) {
                        sum += hidden[j] * this.hiddenToOutput[j][i];
                    }
                    outputs[i] = this.activate(sum);
                }

                return outputs;
            }

            // Activation function - keeps values between 0 and 1
            activate(x) {
                return 1 / (1 + Math.exp(-x)); // Sigmoid function
            }

            // Create a copy of this neural network
            copy() {
                let copy = new NeuralNetwork();
                
                // Copy all weights and biases
                for (let i = 0; i < this.inputToHidden.length; i++) {
                    for (let j = 0; j < this.inputToHidden[i].length; j++) {
                        copy.inputToHidden[i][j] = this.inputToHidden[i][j];
                    }
                }

                for (let i = 0; i < this.hiddenToOutput.length; i++) {
                    for (let j = 0; j < this.hiddenToOutput[i].length; j++) {
                        copy.hiddenToOutput[i][j] = this.hiddenToOutput[i][j];
                    }
                }

                for (let i = 0; i < this.hiddenBias.length; i++) {
                    copy.hiddenBias[i] = this.hiddenBias[i];
                }

                for (let i = 0; i < this.outputBias.length; i++) {
                    copy.outputBias[i] = this.outputBias[i];
                }

                return copy;
            }

            // Mutate the network (make small random changes)
            mutate(rate) {
                // Mutate input to hidden weights
                for (let i = 0; i < this.inputToHidden.length; i++) {
                    for (let j = 0; j < this.inputToHidden[i].length; j++) {
                        if (Math.random() < rate) {
                            this.inputToHidden[i][j] += (Math.random() * 0.2) - 0.1;
                        }
                    }
                }

                // Mutate hidden to output weights
                for (let i = 0; i < this.hiddenToOutput.length; i++) {
                    for (let j = 0; j < this.hiddenToOutput[i].length; j++) {
                        if (Math.random() < rate) {
                            this.hiddenToOutput[i][j] += (Math.random() * 0.2) - 0.1;
                        }
                    }
                }

                // Mutate biases
                for (let i = 0; i < this.hiddenBias.length; i++) {
                    if (Math.random() < rate) {
                        this.hiddenBias[i] += (Math.random() * 0.2) - 0.1;
                    }
                }

                for (let i = 0; i < this.outputBias.length; i++) {
                    if (Math.random() < rate) {
                        this.outputBias[i] += (Math.random() * 0.2) - 0.1;
                    }
                }
            }
        }

        // ===== WALL CLASS =====
        // Represents deadly obstacles in the environment
        class Wall {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.type = 'WALL';
            }

            // Draw the wall
            draw() {
                let pixelX = this.x * CONFIG.GRID_SIZE;
                let pixelY = this.y * CONFIG.GRID_SIZE;
                
                ctx.fillStyle = CONFIG.COLORS.WALL;
                ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                
                // Add danger indicator (red outline)
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(pixelX + 1, pixelY + 1, CONFIG.GRID_SIZE - 3, CONFIG.GRID_SIZE - 3);
            }
        }

        // ===== CREATURE CLASS =====
        // Represents individual creatures in the simulation
        class Creature {
            constructor(x, y, type = 'NEUTRAL') {
                // Position on the grid
                this.x = x || Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE));
                this.y = y || Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE));
                
                // Creature properties
                this.type = type;               // HUNTER, PREY, or NEUTRAL
                this.brain = new NeuralNetwork(); // The creature's neural network
                this.fitness = 0;               // How well this creature performs
                this.energy = CONFIG.STARTING_ENERGY; // Energy level (affects survival)
                this.age = 0;                   // How long the creature has lived
                
                // NEW: Elimination system
                this.isAlive = true;            // Whether creature is still active
                this.timesTagged = 0;           // How many times this creature was tagged
                this.eliminationReason = '';   // Why creature was eliminated
                
                // Movement and behavior
                this.lastMove = { x: 0, y: 0 }; // Track movement for fitness
                this.tags = 0;                  // Number of successful tags
                this.timeAlive = 0;             // Survival time
                this.timeSinceLastTag = 0;      // Used for fitness calculation
                this.timesSurvived = 0;         // Frames survived without being tagged
                
                // Ensure starting position is not on a wall
                this.findSafeStartingPosition();
            }

            // NEW: Find a safe starting position (not on walls or other creatures)
            findSafeStartingPosition() {
                let attempts = 0;
                let maxAttempts = 100;
                
                while (attempts < maxAttempts) {
                    let testX = Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE));
                    let testY = Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE));
                    
                    if (this.isPositionSafe(testX, testY)) {
                        this.x = testX;
                        this.y = testY;
                        return;
                    }
                    attempts++;
                }
                
                // If no safe position found, use current position and hope for the best
                console.warn('Could not find safe starting position for creature');
            }

            // NEW: Check if a position is safe (no walls, no other creatures)
            isPositionSafe(x, y) {
                // Check boundaries
                if (x < 0 || x >= CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE ||
                    y < 0 || y >= CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE) {
                    return false;
                }
                
                // Check for walls
                for (let wall of walls) {
                    if (wall.x === x && wall.y === y) {
                        return false;
                    }
                }
                
                // Check for other creatures
                for (let creature of creatures) {
                    if (creature !== this && creature.isAlive && 
                        creature.x === x && creature.y === y) {
                        return false;
                    }
                }
                
                return true;
            }

            // Get sensory input from the environment
            getInputs() {
                let inputs = [];
                
                // Vision system - look in 8 directions around the creature
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],  // Top row
                    [0, -1],           [0, 1],    // Middle row (skip center)
                    [1, -1],  [1, 0],  [1, 1]    // Bottom row
                ];

                for (let dir of directions) {
                    let visionData = this.lookInDirection(dir[0], dir[1]);
                    
                    // Input represents what the creature sees in this direction
                    // 0 = wall/boundary, 0.5 = creature, 1 = empty space
                    inputs.push(visionData);
                }

                return inputs;
            }

            // NEW: Enhanced vision system that detects walls and creatures
            lookInDirection(dirX, dirY) {
                // Check each position in the direction up to vision range
                for (let distance = 1; distance <= CONFIG.VISION_RANGE; distance++) {
                    let checkX = this.x + (dirX * distance);
                    let checkY = this.y + (dirY * distance);
                    
                    // Check bounds
                    if (checkX < 0 || checkX >= CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE ||
                        checkY < 0 || checkY >= CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE) {
                        return 0; // Hit boundary
                    }
                    
                    // Check for walls (highest priority - danger!)
                    for (let wall of walls) {
                        if (wall.x === checkX && wall.y === checkY) {
                            return 0; // Wall detected
                        }
                    }
                    
                    // Check for other living creatures
                    for (let creature of creatures) {
                        if (creature !== this && creature.isAlive && 
                            creature.x === checkX && creature.y === checkY) {
                            // Return different values based on creature type relationship
                            if (this.type === 'HUNTER' && creature.type === 'PREY') {
                                return 0.8; // Target found!
                            } else if (this.type === 'PREY' && creature.type === 'HUNTER') {
                                return 0.2; // Danger!
                            } else {
                                return 0.5; // Neutral creature
                            }
                        }
                    }
                }
                
                return 1; // Clear path
            }

            // Make a decision about movement
            think() {
                // Only think if alive
                if (!this.isAlive) return;
                
                let inputs = this.getInputs();
                let outputs = this.brain.feedForward(inputs);
                
                // Outputs represent desire to move in each direction
                // [UP, DOWN, LEFT, RIGHT]
                let maxOutput = Math.max(...outputs);
                let chosenDirection = outputs.indexOf(maxOutput);
                
                // Move based on the neural network's decision
                this.move(chosenDirection);
            }

            // Move the creature in a chosen direction
            move(direction) {
                if (!this.isAlive) return;
                
                let newX = this.x;
                let newY = this.y;
                
                // Calculate new position based on direction
                switch(direction) {
                    case 0: newY--; break; // UP
                    case 1: newY++; break; // DOWN
                    case 2: newX--; break; // LEFT
                    case 3: newX++; break; // RIGHT
                }
                
                // Check if the new position is safe
                if (this.isPositionSafe(newX, newY)) {
                    this.lastMove.x = newX - this.x;
                    this.lastMove.y = newY - this.y;
                    this.x = newX;
                    this.y = newY;
                    
                    // Use energy for movement
                    this.energy -= CONFIG.ENERGY_MOVE_COST;
                } else {
                    // Failed to move - check if it's because of a wall
                    this.checkWallCollision(newX, newY);
                }
                
                // Update creature state
                this.age++;
                this.timeAlive++;
                this.timeSinceLastTag++;
                this.timesSurvived++;
                
                // Lose energy over time
                this.energy -= CONFIG.ENERGY_DECAY;
                
                // Gain energy for surviving (if prey/hider)
                if (this.type === 'PREY' && this.timeSinceLastTag > 0) {
                    this.energy += CONFIG.ENERGY_GAIN_SURVIVAL;
                }
                
                // Check for elimination conditions
                this.checkElimination();
            }

            // NEW: Check collision with walls and apply damage
            checkWallCollision(attemptedX, attemptedY) {
                for (let wall of walls) {
                    if (wall.x === attemptedX && wall.y === attemptedY) {
                        // Hit a wall! Take damage
                        this.energy -= CONFIG.WALL_KILL_ENERGY;
                        console.log(`${this.type} creature hit wall! Energy: ${this.energy.toFixed(1)}`);
                        
                        // Add visual feedback for wall collision
                        this.lastWallHit = 10; // Frames to show damage effect
                        break;
                    }
                }
            }

            // NEW: Check if creature should be eliminated
            checkElimination() {
                if (!this.isAlive) return;
                
                // Check energy death
                if (this.energy <= CONFIG.ENERGY_DEATH_THRESHOLD) {
                    this.eliminate('Energy Depleted');
                    return;
                }
                
                // Check tag limit
                if (this.timesTagged >= CONFIG.MAX_TAGS_BEFORE_OUT) {
                    this.eliminate('Tagged Out');
                    return;
                }
                
                // Keep energy within reasonable bounds
                this.energy = Math.max(0, Math.min(CONFIG.STARTING_ENERGY * 1.5, this.energy));
            }

            // NEW: Eliminate creature from simulation
            eliminate(reason) {
                this.isAlive = false;
                this.eliminationReason = reason;
                console.log(`${this.type} creature eliminated: ${reason}`);
            }

            // Calculate fitness based on the current game mode
            calculateFitness() {
                // Base fitness starts with survival time
                let baseFitness = this.timeAlive * 1.0;
                
                switch(gameMode) {
                    case 'tag':
                        if (this.type === 'HUNTER') {
                            // Hunters rewarded for tags, survival, and movement
                            this.fitness = baseFitness + 
                                          (this.tags * 150) + 
                                          (this.energy * 0.5) +
                                          (Math.abs(this.lastMove.x) + Math.abs(this.lastMove.y)) * 2.0;
                        } else {
                            // Prey rewarded for survival, avoiding tags, maintaining energy
                            this.fitness = baseFitness * 2.0 + 
                                          (this.energy * 1.0) +
                                          (this.timesSurvived * 0.5) -
                                          (this.timesTagged * 100);
                        }
                        break;
                        
                    case 'hideSeek':
                        if (this.type === 'PREY') {
                            // Prey tries to hide and survive
                            this.fitness = baseFitness * 1.5 + 
                                          (this.getAverageDistanceToHunters() * 20) +
                                          (this.energy * 1.0) +
                                          (this.timesSurvived * 1.0);
                        } else {
                            // Hunters try to find and tag prey
                            this.fitness = baseFitness + 
                                          (this.tags * 200) + 
                                          (this.energy * 0.5);
                        }
                        break;
                        
                    case 'mixed':
                        // Balanced fitness for exploration, survival, and interaction
                        this.fitness = baseFitness + 
                                      (this.tags * 100) + 
                                      (this.energy * 0.8) +
                                      (this.timesSurvived * 0.3) +
                                      (Math.abs(this.lastMove.x) + Math.abs(this.lastMove.y)) * 1.5;
                        break;
                }
                
                // Bonus for being alive
                if (this.isAlive) {
                    this.fitness += 50;
                }
                
                // Penalty for elimination
                if (!this.isAlive) {
                    if (this.eliminationReason === 'Energy Depleted') {
                        this.fitness *= 0.5; // Heavy penalty for poor energy management
                    } else if (this.eliminationReason === 'Tagged Out') {
                        this.fitness *= 0.7; // Moderate penalty for being caught
                    }
                }
                
                // Ensure fitness is never negative
                this.fitness = Math.max(0, this.fitness);
            }

            // Helper function to calculate average distance to hunters specifically
            getAverageDistanceToHunters() {
                let hunters = creatures.filter(c => c.type === 'HUNTER' && c.isAlive && c !== this);
                if (hunters.length === 0) return 10; // Max distance if no hunters
                
                let totalDistance = 0;
                for (let hunter of hunters) {
                    let distance = Math.sqrt(
                        Math.pow(this.x - hunter.x, 2) + 
                        Math.pow(this.y - hunter.y, 2)
                    );
                    totalDistance += distance;
                }
                
                return totalDistance / hunters.length;
            }

            // Check for tagging with other creatures
            checkForTags() {
                if (!this.isAlive) return;
                
                for (let other of creatures) {
                    if (other !== this && other.isAlive) {
                        let distance = Math.sqrt(
                            Math.pow(this.x - other.x, 2) + 
                            Math.pow(this.y - other.y, 2)
                        );
                        
                        if (distance <= CONFIG.TAG_DISTANCE) {
                            // Tag occurred!
                            if (this.type === 'HUNTER' && other.type === 'PREY') {
                                // Hunter tags prey
                                this.tags++;
                                other.timesTagged++;
                                this.timeSinceLastTag = 0;
                                other.timeSinceLastTag = 0;
                                
                                // Energy transfer
                                this.energy += CONFIG.ENERGY_GAIN_TAG;
                                other.energy -= CONFIG.ENERGY_GAIN_TAG * 0.5;
                                
                                stats.tags++;
                                console.log(`Hunter tagged prey! Hunter energy: ${this.energy.toFixed(1)}, Prey energy: ${other.energy.toFixed(1)}, Prey tags: ${other.timesTagged}`);
                            }
                        }
                    }
                }
            }

            // Draw the creature on the canvas
            draw() {
                if (!this.isAlive) {
                    // Draw eliminated creatures as faded ghosts
                    this.drawEliminated();
                    return;
                }
                
                let pixelX = this.x * CONFIG.GRID_SIZE;
                let pixelY = this.y * CONFIG.GRID_SIZE;
                
                // Choose color based on type
                let color = CONFIG.COLORS[this.type];
                
                // Transparency based on energy level
                let alpha = Math.max(0.3, this.energy / CONFIG.STARTING_ENERGY);
                
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                
                // Draw the creature as a square
                ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                
                // Energy bar
                this.drawEnergyBar(pixelX, pixelY);
                
                // Wall collision effect
                if (this.lastWallHit && this.lastWallHit > 0) {
                    ctx.fillStyle = '#ff0000';
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                    this.lastWallHit--;
                }
                
                // Tag indicator (if recently tagged)
                if (this.timesTagged > 0 && this.timeSinceLastTag < 30) {
                    ctx.fillStyle = '#ffff00';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(pixelX + 2, pixelY + 2, CONFIG.GRID_SIZE - 5, CONFIG.GRID_SIZE - 5);
                }
                
                ctx.globalAlpha = 1.0;
            }

            // NEW: Draw energy bar above creature
            drawEnergyBar(x, y) {
                let barWidth = CONFIG.GRID_SIZE - 4;
                let barHeight = 3;
                let energyPercentage = Math.max(0, this.energy / CONFIG.STARTING_ENERGY);
                
                // Background
                ctx.fillStyle = '#333333';
                ctx.globalAlpha = 0.8;
                ctx.fillRect(x + 2, y - 6, barWidth, barHeight);
                
                // Energy fill
                if (energyPercentage > 0.6) {
                    ctx.fillStyle = '#00ff00';
                } else if (energyPercentage > 0.3) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                
                ctx.fillRect(x + 2, y - 6, barWidth * energyPercentage, barHeight);
            }

            // NEW: Draw eliminated creatures
            drawEliminated() {
                let pixelX = this.x * CONFIG.GRID_SIZE;
                let pixelY = this.y * CONFIG.GRID_SIZE;
                
                // Draw as gray ghost
                ctx.fillStyle = '#666666';
                ctx.globalAlpha = 0.2;
                ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                
                // Draw X to show elimination
                ctx.strokeStyle = '#ff0000';
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pixelX + 2, pixelY + 2);
                ctx.lineTo(pixelX + CONFIG.GRID_SIZE - 3, pixelY + CONFIG.GRID_SIZE - 3);
                ctx.moveTo(pixelX + CONFIG.GRID_SIZE - 3, pixelY + 2);
                ctx.lineTo(pixelX + 2, pixelY + CONFIG.GRID_SIZE - 3);
                ctx.stroke();
                
                ctx.globalAlpha = 1.0;
            }
        }

        // ===== GENETIC ALGORITHM FUNCTIONS =====
        // These functions handle evolution between generations

        // Create the next generation through evolution
        function evolvePopulation() {
            // Calculate fitness for all creatures
            creatures.forEach(creature => creature.calculateFitness());
            
            // Sort by fitness (highest first)
            creatures.sort((a, b) => b.fitness - a.fitness);
            
            // Update statistics
            updateStats();
            
            let newPopulation = [];
            let eliteCount = Math.floor(CONFIG.POPULATION_SIZE * CONFIG.ELITE_PERCENTAGE);
            
            // Keep the best performers (elitism)
            for (let i = 0; i < eliteCount; i++) {
                let elite = new Creature(
                    Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE)),
                    Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE)),
                    creatures[i].type
                );
                elite.brain = creatures[i].brain.copy();
                newPopulation.push(elite);
            }
            
            // Create offspring for the rest of the population
            while (newPopulation.length < CONFIG.POPULATION_SIZE) {
                // Select two parents using tournament selection
                let parent1 = tournamentSelection();
                let parent2 = tournamentSelection();
                
                // Create child
                let child = new Creature(
                    Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE)),
                    Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE)),
                    Math.random() < 0.5 ? parent1.type : parent2.type
                );
                
                // Crossover (combine parent brains)
                if (Math.random() < CONFIG.CROSSOVER_RATE) {
                    child.brain = crossover(parent1.brain, parent2.brain);
                } else {
                    child.brain = parent1.brain.copy();
                }
                
                // Mutate the child
                child.brain.mutate(CONFIG.MUTATION_RATE);
                
                newPopulation.push(child);
            }
            
            // Replace old population
            creatures = newPopulation;
            generation++;
            frameCount = 0;
            stats.tags = 0;
            
            console.log(`Generation ${generation} - Best Fitness: ${stats.bestFitness.toFixed(2)}`);
        }

        // Tournament selection - pick the best from a random group
        function tournamentSelection() {
            let tournamentSize = 5;
            let tournament = [];
            
            for (let i = 0; i < tournamentSize; i++) {
                tournament.push(creatures[Math.floor(Math.random() * creatures.length)]);
            }
            
            tournament.sort((a, b) => b.fitness - a.fitness);
            return tournament[0];
        }

        // Crossover - combine two neural networks
        function crossover(brain1, brain2) {
            let child = new NeuralNetwork();
            
            // Randomly choose weights from either parent
            for (let i = 0; i < brain1.inputToHidden.length; i++) {
                for (let j = 0; j < brain1.inputToHidden[i].length; j++) {
                    child.inputToHidden[i][j] = Math.random() < 0.5 ? 
                        brain1.inputToHidden[i][j] : brain2.inputToHidden[i][j];
                }
            }
            
            for (let i = 0; i < brain1.hiddenToOutput.length; i++) {
                for (let j = 0; j < brain1.hiddenToOutput[i].length; j++) {
                    child.hiddenToOutput[i][j] = Math.random() < 0.5 ? 
                        brain1.hiddenToOutput[i][j] : brain2.hiddenToOutput[i][j];
                }
            }
            
            for (let i = 0; i < brain1.hiddenBias.length; i++) {
                child.hiddenBias[i] = Math.random() < 0.5 ? 
                    brain1.hiddenBias[i] : brain2.hiddenBias[i];
            }
            
            for (let i = 0; i < brain1.outputBias.length; i++) {
                child.outputBias[i] = Math.random() < 0.5 ? 
                    brain1.outputBias[i] : brain2.outputBias[i];
            }
            
            return child;
        }

        // ===== SIMULATION FUNCTIONS =====

        // Initialize the simulation
        function init() {
            // Set up canvas
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CONFIG.CANVAS_WIDTH;
            canvas.height = CONFIG.CANVAS_HEIGHT;
            
            // Create initial population
            createInitialPopulation();
            
            // Set up event listeners
            setupEventListeners();
            
            // Start the main game loop
            gameLoop();
        }

        // Create the initial population of creatures
        function createInitialPopulation() {
            creatures = [];
            
            // Create walls first
            createWalls();
            
            for (let i = 0; i < CONFIG.POPULATION_SIZE; i++) {
                let type;
                
                // Assign creature types based on game mode
                switch(gameMode) {
                    case 'tag':
                        type = i < CONFIG.POPULATION_SIZE / 2 ? 'HUNTER' : 'PREY';
                        break;
                    case 'hideSeek':
                        type = i < CONFIG.POPULATION_SIZE * 0.2 ? 'HUNTER' : 'PREY';
                        break;
                    case 'mixed':
                        if (i < CONFIG.POPULATION_SIZE * 0.3) type = 'HUNTER';
                        else if (i < CONFIG.POPULATION_SIZE * 0.6) type = 'PREY';
                        else type = 'NEUTRAL';
                        break;
                }
                
                let creature = new Creature(undefined, undefined, type);
                creatures.push(creature);
            }
        }

        // NEW: Create walls in the environment
        function createWalls() {
            walls = [];
            let gridWidth = Math.floor(CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE);
            let gridHeight = Math.floor(CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE);
            let totalCells = gridWidth * gridHeight;
            let wallCount = Math.floor(totalCells * CONFIG.WALL_DENSITY);
            
            for (let i = 0; i < wallCount; i++) {
                let x = Math.floor(Math.random() * gridWidth);
                let y = Math.floor(Math.random() * gridHeight);
                
                // Make sure we don't place walls on top of each other
                let wallExists = walls.some(wall => wall.x === x && wall.y === y);
                if (!wallExists) {
                    walls.push(new Wall(x, y));
                }
            }
            
            console.log(`Created ${walls.length} walls`);
        }

        // Main game loop
        function gameLoop() {
            if (!isPaused) {
                update();
                draw();
                
                frameCount++;
                
                // Check if it's time to evolve
                if (frameCount >= CONFIG.GENERATION_LENGTH) {
                    evolvePopulation();
                }
            }
            
            // Continue the loop
            requestAnimationFrame(gameLoop);
        }

        // Update all creatures
        function update() {
            let aliveCreatures = creatures.filter(c => c.isAlive);
            
            // Update only living creatures
            aliveCreatures.forEach(creature => {
                creature.think();
                creature.checkForTags();
                creature.calculateFitness();
            });
            
            // Update statistics
            stats.aliveCount = aliveCreatures.length;
            stats.eliminatedCount = creatures.length - aliveCreatures.length;
            
            // Check if we need to evolve early (if too few creatures alive)
            if (aliveCreatures.length < CONFIG.POPULATION_SIZE * 0.1) {
                console.log('Most creatures eliminated, forcing evolution...');
                evolvePopulation();
            }
            
            // Update UI
            updateDisplay();
        }

        // Draw everything
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid (optional)
            drawGrid();
            
            // Draw walls first
            walls.forEach(wall => wall.draw());
            
            // Draw all creatures (living and eliminated)
            creatures.forEach(creature => creature.draw());
        }

        // Draw grid lines (helpful for visualization)
        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 0.5;
            
            // Vertical lines
            for (let x = 0; x < canvas.width; x += CONFIG.GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y < canvas.height; y += CONFIG.GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Update statistics
        function updateStats() {
            if (creatures.length > 0) {
                stats.bestFitness = Math.max(...creatures.map(c => c.fitness));
                stats.avgFitness = creatures.reduce((sum, c) => sum + c.fitness, 0) / creatures.length;
            }
        }

        // Update the display elements
        function updateDisplay() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('bestFitness').textContent = stats.bestFitness.toFixed(2);
            document.getElementById('avgFitness').textContent = stats.avgFitness.toFixed(2);
            document.getElementById('tagCount').textContent = stats.tags;
            document.getElementById('aliveCount').textContent = stats.aliveCount;
            document.getElementById('eliminatedCount').textContent = stats.eliminatedCount;
        }

        // ===== EVENT LISTENERS =====
        function setupEventListeners() {
            // Population size control
            document.getElementById('populationSize').addEventListener('input', function(e) {
                CONFIG.POPULATION_SIZE = parseInt(e.target.value);
                document.getElementById('popDisplay').textContent = e.target.value;
            });

            // Simulation speed control
            document.getElementById('simSpeed').addEventListener('input', function(e) {
                CONFIG.GENERATION_LENGTH = Math.floor(2000 / parseFloat(e.target.value));
                document.getElementById('speedDisplay').textContent = e.target.value + 'x';
            });

            // Mutation rate control
            document.getElementById('mutationRate').addEventListener('input', function(e) {
                CONFIG.MUTATION_RATE = parseFloat(e.target.value);
                document.getElementById('mutationDisplay').textContent = e.target.value;
            });

            // Grid size control
            document.getElementById('gridSize').addEventListener('input', function(e) {
                CONFIG.GRID_SIZE = parseInt(e.target.value);
                document.getElementById('gridDisplay').textContent = e.target.value;
            });

            // NEW: Wall density control
            document.getElementById('wallDensity').addEventListener('input', function(e) {
                CONFIG.WALL_DENSITY = parseFloat(e.target.value) / 100;
                document.getElementById('wallDisplay').textContent = e.target.value + '%';
            });

            // NEW: Energy decay control
            document.getElementById('energyDecay').addEventListener('input', function(e) {
                CONFIG.ENERGY_DECAY = parseFloat(e.target.value);
                document.getElementById('energyDecayDisplay').textContent = e.target.value;
            });

            // Game mode selection
            document.getElementById('gameMode').addEventListener('change', function(e) {
                gameMode = e.target.value;
                createInitialPopulation(); // Restart with new mode
                generation = 1;
                frameCount = 0;
            });

            // Control buttons
            document.getElementById('pauseBtn').addEventListener('click', function() {
                isPaused = !isPaused;
                this.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            });

            document.getElementById('resetBtn').addEventListener('click', function() {
                createInitialPopulation();
                generation = 1;
                frameCount = 0;
                stats.tags = 0;
                stats.aliveCount = 0;
                stats.eliminatedCount = 0;
            });

            document.getElementById('evolveBtn').addEventListener('click', function() {
                evolvePopulation();
            });

            // Resize canvas when window resizes
            window.addEventListener('resize', function() {
                CONFIG.CANVAS_WIDTH = window.innerWidth;
                CONFIG.CANVAS_HEIGHT = window.innerHeight;
                canvas.width = CONFIG.CANVAS_WIDTH;
                canvas.height = CONFIG.CANVAS_HEIGHT;
            });
        }

        // ===== START THE SIMULATION =====
        // Wait for the page to load, then initialize
        window.addEventListener('load', init);

        /* ===============================
         * HOW TO CUSTOMIZE THIS SIMULATION:
         * 
         * 1. Modify CONFIG object at the top to change basic parameters
         * 2. Adjust creature types and behaviors in the Creature class
         * 3. Change fitness functions in calculateFitness() method
         * 4. Modify neural network structure in NeuralNetwork class
         * 5. Add new input types in getInputs() method
         * 6. Create new game modes by modifying the gameMode switch statements
         * 7. Adjust evolution parameters in the genetic algorithm functions
         * 
         * NEW FEATURES ADDED:
         * - Energy system: Creatures lose energy over time and when moving
         * - Elimination: Creatures die from energy depletion or being tagged 3 times
         * - Collision detection: Creatures cannot occupy the same space
         * - Deadly walls: Touch walls to lose energy (configurable)
         * - Enhanced vision: Creatures can see walls and different creature types
         * - Visual feedback: Energy bars, elimination indicators, wall collision effects
         * 
         * EXPERIMENT IDEAS:
         * - Adjust energy gain/loss rates for different behaviors
         * - Create safe zones where creatures can recover energy
         * - Add different wall types (some beneficial, some harmful)
         * - Implement pack hunting or group behaviors
         * - Add seasonal effects (walls appear/disappear over time)
         * - Create power-ups that give temporary abilities
         * - Add different creature species with unique energy requirements
         * - Implement breeding mechanics where successful creatures reproduce
         * - Add sound/vibration detection as additional inputs
         * - Create maze-like environments with strategic wall placement
         * =============================== */
    </script>
</body>
</html>