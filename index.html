<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEAT Creatures - Tag & Hide and Seek</title>
    <style>
        /* ===== VISUAL STYLING ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }

        /* Collapsible control panels */
        .control-panel {
            position: absolute;
            background: rgba(15, 15, 20, 0.95);
            border: 2px solid #333;
            border-radius: 8px;
            z-index: 1000;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .panel-header {
            background: rgba(50, 50, 60, 0.9);
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
        }

        .panel-header:hover {
            background: rgba(70, 70, 80, 0.9);
        }

        .panel-content {
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
        }

        .panel-content.collapsed {
            max-height: 0;
            padding: 0 10px;
            overflow: hidden;
        }

        /* Main controls panel */
        .main-controls {
            top: 10px;
            left: 10px;
            width: 300px;
        }

        /* Info panel */
        .info-panel {
            top: 10px;
            right: 10px;
            width: 350px;
        }

        /* Analytics panel */
        .analytics-panel {
            bottom: 10px;
            left: 10px;
            width: 400px;
        }

        /* Neural network visualization panel */
        .neural-viz-panel {
            bottom: 10px;
            right: 10px;
            width: 350px;
        }

        .control-group {
            margin-bottom: 8px;
        }

        .control-group label {
            display: block;
            margin-bottom: 3px;
            color: #ccc;
            font-size: 11px;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 3px;
        }

        input[type="number"] {
            width: 60px;
            padding: 2px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
        }

        select {
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 4px;
            width: 100%;
        }

        button {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }

        button:hover {
            background: #555;
        }

        .stats {
            font-size: 10px;
            color: #aaa;
            line-height: 1.4;
        }

        /* Neural network visualization */
        .neural-canvas {
            background: #111;
            border: 1px solid #444;
            border-radius: 4px;
            margin: 5px 0;
        }

        /* Ability breakdown */
        .ability-list {
            font-size: 10px;
            line-height: 1.3;
        }

        .ability-item {
            margin: 3px 0;
            padding: 3px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .hunter-ability {
            border-left: 3px solid #ff4444;
        }

        .prey-ability {
            border-left: 3px solid #4444ff;
        }

        /* Mutation stats */
        .mutation-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 10px;
        }

        .mutation-stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 4px;
            border-radius: 3px;
            text-align: center;
        }

        /* Canvas styling */
        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        /* Scrollbar styling */
        .panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .panel-content::-webkit-scrollbar-track {
            background: #222;
        }

        .panel-content::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 3px;
        }

        .panel-content::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Analytics and Visualization Styles */
        .neural-canvas {
            border: 1px solid #444;
            border-radius: 4px;
            background: #1a1a1a;
            display: block;
            margin: 2px 0;
        }

        .mutation-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 3px;
            margin-bottom: 8px;
        }

        .stat-item {
            font-size: 9px;
            background: #2a2a2a;
            padding: 2px 4px;
            border-radius: 2px;
            border-left: 2px solid #66ff66;
        }

        .top-performer {
            background: #2a2a2a;
            padding: 4px;
            margin: 2px 0;
            border-radius: 3px;
            border-left: 3px solid #ffaa00;
            font-size: 9px;
            line-height: 1.2;
        }

        .ability-list {
            max-height: 120px;
            overflow-y: auto;
        }

        /* Turbo mode styling */
        .turbo-status {
            font-size: 10px;
            color: #ffaa00;
            margin-top: 5px;
            text-align: center;
        }

        #turboBtn {
            background: linear-gradient(45deg, #ff6600, #ffaa00);
            border: none;
            color: white;
            font-weight: bold;
        }

        #turboBtn:hover {
            background: linear-gradient(45deg, #ff8800, #ffcc00);
        }

        #turboBtn.active {
            background: linear-gradient(45deg, #cc0000, #ff0000);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .ability-item {
            font-size: 9px;
            line-height: 1.3;
            margin: 3px 0;
            padding: 3px 5px;
            border-radius: 3px;
            background: #2a2a2a;
        }

        .hunter-ability {
            border-left: 3px solid #ff6666;
        }

        .prey-ability {
            border-left: 3px solid #6666ff;
        }
    </style>
</head>
<body>
    <!-- ===== MAIN CONTROLS PANEL ===== -->
    <div class="control-panel main-controls">
        <div class="panel-header" onclick="togglePanel('main-controls')">
            üéõÔ∏è Simulation Controls
            <span id="main-controls-arrow">‚ñº</span>
        </div>
        <div class="panel-content" id="main-controls-content">
            <!-- Population Settings -->
            <div class="control-group">
                <label>Population: <span id="popDisplay">50</span></label>
                <input type="range" id="populationSize" min="10" max="200" value="50">
            </div>

            <!-- Speed Controls -->
            <div class="control-group">
                <label>Speed: <span id="speedDisplay">1.0x</span></label>
                <input type="range" id="simSpeed" min="0.1" max="50.0" step="0.1" value="1.0">
            </div>
            
            <!-- NEW: Timer Controls -->
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showTimer" checked> Show Timer
                </label>
                <div id="simulationTimer" style="font-size: 10px; color: #aaa; margin-top: 2px;">
                    Time: 0:00
                </div>
            </div>

            <!-- Game Mode -->
            <div class="control-group">
                <label>Game Mode:</label>
                <select id="gameMode">
                    <option value="tag">Tag (Red chases Blue)</option>
                    <option value="hideSeek">Hide & Seek</option>
                    <option value="mixed">Mixed Behaviors</option>
                </select>
            </div>

            <!-- Environment -->
            <div class="control-group">
                <label>Grid Size: <span id="gridDisplay">20</span></label>
                <input type="range" id="gridSize" min="15" max="40" value="20">
            </div>

            <div class="control-group">
                <label>Wall Density: <span id="wallDisplay">5%</span></label>
                <input type="range" id="wallDensity" min="0" max="15" value="5">
            </div>

            <!-- Evolution Parameters -->
            <div class="control-group">
                <label>Mutation Rate: <span id="mutationDisplay">0.1</span></label>
                <input type="range" id="mutationRate" min="0.01" max="0.5" step="0.01" value="0.1">
            </div>

            <div class="control-group">
                <label>Ability Mutations: <span id="abilityMutationDisplay">5%</span></label>
                <input type="range" id="abilityMutation" min="1" max="20" value="5">
            </div>

            <!-- Controls -->
            <div class="control-group">
                <button id="pauseBtn">‚è∏Ô∏è Pause</button>
                <button id="resetBtn">üîÑ Reset</button>
                <button id="evolveBtn">üß¨ Evolve</button>
                <button id="turboBtn">üöÄ Turbo Mode</button>
            </div>

            <!-- Turbo Mode Settings -->
            <div class="control-group" id="turboControls" style="display: none;">
                <label>Turbo Generations: <span id="turboGenDisplay">100</span></label>
                <input type="range" id="turboGenerations" min="50" max="500" value="100">
                <div class="turbo-status" id="turboStatus"></div>
            </div>

            <!-- Basic Statistics -->
            <div class="stats">
                <div>Generation: <span id="generation">1</span></div>
                <div>Alive: <span id="aliveCount">0</span> | Eliminated: <span id="eliminatedCount">0</span></div>
                <div>Best Fitness: <span id="bestFitness">0</span></div>
                <div>Active Abilities: <span id="abilityCount">0</span></div>
                <div>Neural Diversity: <span id="neuralDiversity">0</span> types</div>
                <div>Topology Changes: <span id="topologyChanges">0</span></div>
            </div>
        </div>
    </div>

    <!-- ===== GAME INFO PANEL ===== -->
    <div class="control-panel info-panel">
        <div class="panel-header" onclick="togglePanel('info-panel')">
            üìñ Game Rules & Abilities
            <span id="info-panel-arrow">‚ñº</span>
        </div>
        <div class="panel-content" id="info-panel-content">
            <h4 style="color: #ff6666; margin-bottom: 8px;">üî¥ HUNTERS (Red)</h4>
            <div class="ability-list">
                <div class="ability-item hunter-ability">
                    <strong>Pack Hunting:</strong> Enhanced prey detection and coordination
                </div>
                <div class="ability-item hunter-ability">
                    <strong>Energy Vampire:</strong> Drain 50% more energy when tagging
                </div>
                <div class="ability-item hunter-ability">
                    <strong>Wall Bounce:</strong> Bounce off walls without damage
                </div>
                <div class="ability-item hunter-ability">
                    <strong>Speed Burst:</strong> Double speed when low energy (5 uses)
                </div>
                <div class="ability-item hunter-ability">
                    <strong>Territorial:</strong> Gain energy near other hunters
                </div>
            </div>

            <h4 style="color: #6666ff; margin: 12px 0 8px 0;">üîµ PREY (Blue)</h4>
            <div class="ability-list">
                <div class="ability-item prey-ability">
                    <strong>Camouflage:</strong> Become invisible to hunters periodically
                </div>
                <div class="ability-item prey-ability">
                    <strong>Evasion:</strong> 30% chance to avoid being tagged
                </div>
                <div class="ability-item prey-ability">
                    <strong>Energy Efficient:</strong> 30% less energy consumption
                </div>
                <div class="ability-item prey-ability">
                    <strong>Wall Phasing:</strong> Pass through walls (3 uses)
                </div>
                <div class="ability-item prey-ability">
                    <strong>Group Healing:</strong> Enhanced cooperative healing
                </div>
            </div>

            <h4 style="color: #ff9999; margin: 12px 0 8px 0;">‚ö†Ô∏è Negative Mutations (Both Types)</h4>
            <div class="ability-list">
                <div class="ability-item" style="border-left: 3px solid #ff6666; background: #2a1a1a;">
                    <strong>Anxiety:</strong> Avoids others, blocks group healing
                </div>
                <div class="ability-item" style="border-left: 3px solid #ff6666; background: #2a1a1a;">
                    <strong>Aggression:</strong> Occasionally attacks own type
                </div>
                <div class="ability-item" style="border-left: 3px solid #ff6666; background: #2a1a1a;">
                    <strong>Paranoia:</strong> Random direction changes, wastes energy
                </div>
                <div class="ability-item" style="border-left: 3px solid #ff6666; background: #2a1a1a;">
                    <strong>Lethargy:</strong> Slower movement, higher energy costs
                </div>
                <div class="ability-item" style="border-left: 3px solid #ff6666; background: #2a1a1a;">
                    <strong>Confusion:</strong> Sometimes moves in wrong direction
                </div>
            </div>

            <h4 style="color: #66ff66; margin: 12px 0 8px 0;">ü§ù Cooperation Rules</h4>
            <div style="font-size: 10px; line-height: 1.4;">
                ‚Ä¢ Same-type creatures can heal each other's tags<br>
                ‚Ä¢ Healing costs energy but removes one tag<br>
                ‚Ä¢ Creatures eliminated after 3 tags or energy depletion<br>
                ‚Ä¢ Strategic wall-baiting can damage opponents<br>
                ‚Ä¢ Teamwork and individual survival both matter
            </div>
        </div>
    </div>

    <!-- ===== ANALYTICS PANEL ===== -->
    <div class="control-panel analytics-panel">
        <div class="panel-header" onclick="togglePanel('analytics-panel')">
            üìä Mutation Analytics
            <span id="analytics-panel-arrow">‚ñº</span>
        </div>
        <div class="panel-content" id="analytics-panel-content">
            <h4 style="margin-bottom: 8px;">Ability Occurrence Rates</h4>
            <div class="mutation-stats" id="mutationStats">
                <!-- Will be populated by JavaScript -->
            </div>
            
            <h4 style="margin: 12px 0 8px 0;">Top Performers</h4>
            <div id="topPerformers" style="font-size: 10px;">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- ===== NEURAL NETWORK VISUALIZATION ===== -->
    <div class="control-panel neural-viz-panel">
        <div class="panel-header" onclick="togglePanel('neural-viz-panel')">
            üß† Neural Network Viz
            <span id="neural-viz-panel-arrow">‚ñº</span>
        </div>
        <div class="panel-content" id="neural-viz-panel-content">
            <h4 style="margin-bottom: 5px;">Best Hunter Brain</h4>
            <canvas class="neural-canvas" id="hunterBrain" width="320" height="120"></canvas>
            
            <h4 style="margin: 10px 0 5px 0;">Best Prey Brain</h4>
            <canvas class="neural-canvas" id="preyBrain" width="320" height="120"></canvas>
            
            <div style="font-size: 9px; margin-top: 8px; color: #888;">
                Connections: Green=Positive, Red=Negative, Thickness=Strength
            </div>
        </div>
    </div>

    <!-- ===== GAME CANVAS ===== -->
    <canvas id="gameCanvas"></canvas>

    <script>
        /* ===============================
         * NEAT CREATURES SIMULATION
         * A modular neural network ecosystem
         * =============================== */

        // ===== CONFIGURATION PARAMETERS =====
        // These are the main tuning parameters you can easily modify
        const CONFIG = {
            // Visual settings
            CANVAS_WIDTH: window.innerWidth,
            CANVAS_HEIGHT: window.innerHeight,
            
            // Grid and creature settings
            GRID_SIZE: 30,              // Size of each grid cell
            POPULATION_SIZE: 50,        // Number of creatures
            
            // Neural network parameters
            INPUT_NODES: 8,             // What creatures can "see"
            HIDDEN_NODES: 6,            // Processing power
            OUTPUT_NODES: 4,            // Movement directions
            
            // Evolution parameters
            MUTATION_RATE: 0.1,         // How much creatures change between generations
            CROSSOVER_RATE: 0.7,       // How often parents combine traits
            ELITE_PERCENTAGE: 0.2,     // Top performers that survive unchanged
            
            // Game mechanics
            CREATURE_SPEED: 1,          // How fast creatures move
            VISION_RANGE: 3,            // How far creatures can see
            TAG_DISTANCE: 1,            // Distance needed to tag
            
            // Energy system
            STARTING_ENERGY: 100,       // Energy creatures start with
            ENERGY_DECAY: 0.2,          // Energy lost per frame
            ENERGY_MOVE_COST: 0.5,      // Extra energy cost for moving
            ENERGY_GAIN_SURVIVAL: 0.3,  // Energy gained for surviving (prey/hiders)
            ENERGY_GAIN_TAG: 20,        // Energy gained for successful tag
            
            // Elimination system
            MAX_TAGS_BEFORE_OUT: 3,     // How many times you can be tagged before elimination
            ENERGY_DEATH_THRESHOLD: 0, // Energy level that causes death
            
            // NEW: Cooperative mechanics
            SAME_TYPE_HEAL_CHANCE: 0.8, // Chance that same-type contact removes tags
            HEAL_ENERGY_COST: 5,        // Energy cost for healing another creature
            
            // NEW: Special mutation system
            MUTATION_ACTIVATION_RATE: 0.05, // Chance to gain new abilities during mutation
            MAX_SPECIAL_ABILITIES: 3,   // Maximum special abilities per creature
            
            // Environment
            WALL_DENSITY: 0.05,         // Percentage of grid filled with deadly walls
            WALL_KILL_ENERGY: 50,       // Energy lost when touching walls
            
            // Evolution timing
            GENERATION_LENGTH: 3000,    // Frames before evolution (longer for new mechanics)
            
            // Colors for different creature types
            COLORS: {
                HUNTER: '#ff4444',      // Red - aggressive/chaser
                PREY: '#4444ff',        // Blue - defensive/hider
                NEUTRAL: '#44ff44',     // Green - balanced
                WALL: '#9966cc'         // Light ghost purple - boundaries
            },
            
            // NEW: Simulation timing and display
            SHOW_TIMER: true,           // Show simulation timer
            MAX_SPEED_MULTIPLIER: 50,   // Allow up to 50x speed for fast iteration
            
            // NEW: NEAT topology evolution
            NODE_ADD_RATE: 0.05,        // Chance to add a hidden node during mutation
            NODE_REMOVE_RATE: 0.02,     // Chance to remove a hidden node during mutation
            MIN_HIDDEN_NODES: 3,        // Minimum number of hidden nodes
            MAX_HIDDEN_NODES: 12,       // Maximum number of hidden nodes
            
            // NEW: Turbo evolution mode
            TURBO_MODE: false,          // Enable turbo evolution mode
            TURBO_GENERATIONS: 100,     // How many generations to run in turbo mode
            TURBO_STATS_INTERVAL: 10    // How often to update stats in turbo mode
        };

        // ===== GLOBAL VARIABLES =====
        let canvas, ctx;
        let creatures = [];
        let walls = [];
        let generation = 1;
        let frameCount = 0;
        let isPaused = false;
        let gameMode = 'tag';
        let stats = {
            tags: 0,
            bestFitness: 0,
            avgFitness: 0,
            aliveCount: 0,
            eliminatedCount: 0
        };
        
        // NEW: Turbo evolution mode
        let turboModeActive = false;
        let turboGenerationsLeft = 0;
        let turboStats = {
            startGeneration: 0,
            bestFitnessHistory: [],
            avgFitnessHistory: [],
            topologyChanges: 0
        };
        
        // NEW: Simulation timing
        let simulationStartTime = 0;
        let simulationPausedTime = 0;
        let lastPauseStart = 0;

        // ===== NEURAL NETWORK CLASS =====
        // This represents the "brain" of each creature
        class NeuralNetwork {
            constructor(hiddenNodeCount = CONFIG.HIDDEN_NODES) {
                // Store the actual number of hidden nodes (can vary for NEAT)
                this.hiddenNodeCount = hiddenNodeCount;
                
                // Initialize random weights for connections between nodes
                // Input layer to hidden layer connections
                this.inputToHidden = this.createMatrix(CONFIG.INPUT_NODES, this.hiddenNodeCount);
                
                // Hidden layer to output layer connections
                this.hiddenToOutput = this.createMatrix(this.hiddenNodeCount, CONFIG.OUTPUT_NODES);
                
                // Bias values (help with decision making)
                this.hiddenBias = this.createArray(this.hiddenNodeCount);
                this.outputBias = this.createArray(CONFIG.OUTPUT_NODES);
                
                // Initialize with random values
                this.randomize();
            }

            // Create a matrix filled with zeros
            createMatrix(rows, cols) {
                let matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = new Array(cols).fill(0);
                }
                return matrix;
            }

            // Create an array filled with zeros
            createArray(size) {
                return new Array(size).fill(0);
            }

            // Fill all weights with random values between -1 and 1
            randomize() {
                // Randomize input to hidden connections
                for (let i = 0; i < this.inputToHidden.length; i++) {
                    for (let j = 0; j < this.inputToHidden[i].length; j++) {
                        this.inputToHidden[i][j] = (Math.random() * 2) - 1;
                    }
                }

                // Randomize hidden to output connections
                for (let i = 0; i < this.hiddenToOutput.length; i++) {
                    for (let j = 0; j < this.hiddenToOutput[i].length; j++) {
                        this.hiddenToOutput[i][j] = (Math.random() * 2) - 1;
                    }
                }

                // Randomize biases
                for (let i = 0; i < this.hiddenBias.length; i++) {
                    this.hiddenBias[i] = (Math.random() * 2) - 1;
                }
                for (let i = 0; i < this.outputBias.length; i++) {
                    this.outputBias[i] = (Math.random() * 2) - 1;
                }
            }

            // Process inputs through the network to get outputs
            feedForward(inputs) {
                // Calculate hidden layer values
                let hidden = [];
                for (let i = 0; i < this.hiddenNodeCount; i++) {
                    let sum = this.hiddenBias[i];
                    for (let j = 0; j < CONFIG.INPUT_NODES; j++) {
                        sum += inputs[j] * this.inputToHidden[j][i];
                    }
                    hidden[i] = this.activate(sum); // Apply activation function
                }

                // Calculate output layer values
                let outputs = [];
                for (let i = 0; i < CONFIG.OUTPUT_NODES; i++) {
                    let sum = this.outputBias[i];
                    for (let j = 0; j < this.hiddenNodeCount; j++) {
                        sum += hidden[j] * this.hiddenToOutput[j][i];
                    }
                    outputs[i] = this.activate(sum);
                }

                return outputs;
            }

            // Activation function - keeps values between 0 and 1
            activate(x) {
                return 1 / (1 + Math.exp(-x)); // Sigmoid function
            }

            // Create a copy of this neural network
            copy() {
                let copy = new NeuralNetwork(this.hiddenNodeCount);
                
                // Copy all weights and biases
                for (let i = 0; i < this.inputToHidden.length; i++) {
                    for (let j = 0; j < this.inputToHidden[i].length; j++) {
                        copy.inputToHidden[i][j] = this.inputToHidden[i][j];
                    }
                }

                for (let i = 0; i < this.hiddenToOutput.length; i++) {
                    for (let j = 0; j < this.hiddenToOutput[i].length; j++) {
                        copy.hiddenToOutput[i][j] = this.hiddenToOutput[i][j];
                    }
                }

                for (let i = 0; i < this.hiddenBias.length; i++) {
                    copy.hiddenBias[i] = this.hiddenBias[i];
                }

                for (let i = 0; i < this.outputBias.length; i++) {
                    copy.outputBias[i] = this.outputBias[i];
                }

                return copy;
            }

            // Mutate the network (make small random changes)
            mutate(rate) {
                // Mutate input to hidden weights
                for (let i = 0; i < this.inputToHidden.length; i++) {
                    for (let j = 0; j < this.inputToHidden[i].length; j++) {
                        if (Math.random() < rate) {
                            this.inputToHidden[i][j] += (Math.random() * 0.2) - 0.1;
                        }
                    }
                }

                // Mutate hidden to output weights
                for (let i = 0; i < this.hiddenToOutput.length; i++) {
                    for (let j = 0; j < this.hiddenToOutput[i].length; j++) {
                        if (Math.random() < rate) {
                            this.hiddenToOutput[i][j] += (Math.random() * 0.2) - 0.1;
                        }
                    }
                }

                // Mutate biases
                for (let i = 0; i < this.hiddenBias.length; i++) {
                    if (Math.random() < rate) {
                        this.hiddenBias[i] += (Math.random() * 0.2) - 0.1;
                    }
                }

                for (let i = 0; i < this.outputBias.length; i++) {
                    if (Math.random() < rate) {
                        this.outputBias[i] += (Math.random() * 0.2) - 0.1;
                    }
                }
                
                // NEW: NEAT topology mutations
                this.mutateTopology();
            }

            // NEW: NEAT topology mutations - add or remove hidden nodes
            mutateTopology() {
                // Try to add a hidden node
                if (Math.random() < CONFIG.NODE_ADD_RATE && 
                    this.hiddenNodeCount < CONFIG.MAX_HIDDEN_NODES) {
                    this.addHiddenNode();
                    turboStats.topologyChanges++;
                }
                
                // Try to remove a hidden node  
                if (Math.random() < CONFIG.NODE_REMOVE_RATE && 
                    this.hiddenNodeCount > CONFIG.MIN_HIDDEN_NODES) {
                    this.removeHiddenNode();
                    turboStats.topologyChanges++;
                }
            }

            // Add a new hidden node to the network
            addHiddenNode() {
                let oldHiddenCount = this.hiddenNodeCount;
                this.hiddenNodeCount++;
                
                // Create new matrices with the additional node
                let newInputToHidden = this.createMatrix(CONFIG.INPUT_NODES, this.hiddenNodeCount);
                let newHiddenToOutput = this.createMatrix(this.hiddenNodeCount, CONFIG.OUTPUT_NODES);
                let newHiddenBias = this.createArray(this.hiddenNodeCount);
                
                // Copy existing weights
                for (let i = 0; i < CONFIG.INPUT_NODES; i++) {
                    for (let j = 0; j < oldHiddenCount; j++) {
                        newInputToHidden[i][j] = this.inputToHidden[i][j];
                    }
                    // Initialize new node connections randomly
                    newInputToHidden[i][oldHiddenCount] = (Math.random() * 2) - 1;
                }
                
                for (let i = 0; i < oldHiddenCount; i++) {
                    for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                        newHiddenToOutput[i][j] = this.hiddenToOutput[i][j];
                    }
                    newHiddenBias[i] = this.hiddenBias[i];
                }
                
                // Initialize new node's output connections and bias
                for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                    newHiddenToOutput[oldHiddenCount][j] = (Math.random() * 2) - 1;
                }
                newHiddenBias[oldHiddenCount] = (Math.random() * 2) - 1;
                
                // Update network
                this.inputToHidden = newInputToHidden;
                this.hiddenToOutput = newHiddenToOutput;
                this.hiddenBias = newHiddenBias;
                
                console.log(`Added hidden node: ${oldHiddenCount} -> ${this.hiddenNodeCount}`);
            }

            // Remove a hidden node from the network
            removeHiddenNode() {
                if (this.hiddenNodeCount <= CONFIG.MIN_HIDDEN_NODES) return;
                
                let oldHiddenCount = this.hiddenNodeCount;
                this.hiddenNodeCount--;
                
                // Choose a random node to remove
                let nodeToRemove = Math.floor(Math.random() * oldHiddenCount);
                
                // Create new matrices without the removed node
                let newInputToHidden = this.createMatrix(CONFIG.INPUT_NODES, this.hiddenNodeCount);
                let newHiddenToOutput = this.createMatrix(this.hiddenNodeCount, CONFIG.OUTPUT_NODES);
                let newHiddenBias = this.createArray(this.hiddenNodeCount);
                
                // Copy weights, skipping the removed node
                for (let i = 0; i < CONFIG.INPUT_NODES; i++) {
                    let newJ = 0;
                    for (let j = 0; j < oldHiddenCount; j++) {
                        if (j !== nodeToRemove) {
                            newInputToHidden[i][newJ] = this.inputToHidden[i][j];
                            newJ++;
                        }
                    }
                }
                
                let newI = 0;
                for (let i = 0; i < oldHiddenCount; i++) {
                    if (i !== nodeToRemove) {
                        for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                            newHiddenToOutput[newI][j] = this.hiddenToOutput[i][j];
                        }
                        newHiddenBias[newI] = this.hiddenBias[i];
                        newI++;
                    }
                }
                
                // Update network
                this.inputToHidden = newInputToHidden;
                this.hiddenToOutput = newHiddenToOutput;
                this.hiddenBias = newHiddenBias;
                
                console.log(`Removed hidden node: ${oldHiddenCount} -> ${this.hiddenNodeCount}`);
            }

            // NEW: Mutate special abilities for creatures
            mutateSpecialAbilities(creature) {
                // Count current abilities
                let currentAbilityCount = Object.values(creature.specialAbilities).filter(Boolean).length;
                
                if (currentAbilityCount >= CONFIG.MAX_SPECIAL_ABILITIES) return;
                
                // Determine which abilities can be unlocked based on creature type
                let availableAbilities = [];
                if (creature.type === 'HUNTER') {
                    availableAbilities = ['packHunting', 'energyVampire', 'wallBounce', 'speedBurst', 'territorialInstinct'];
                } else if (creature.type === 'PREY') {
                    availableAbilities = ['camouflage', 'evasion', 'energyEfficiency', 'wallPhasing', 'groupHealing'];
                }
                
                // NEW: Negative mutations available to both types
                const negativeAbilities = ['anxiety', 'aggression', 'paranoia', 'lethargy', 'confusion'];
                availableAbilities = [...availableAbilities, ...negativeAbilities];
                
                // Filter out already-acquired abilities
                availableAbilities = availableAbilities.filter(ability => !creature.specialAbilities[ability]);
                
                if (availableAbilities.length === 0) return;
                
                // Chance to gain a new ability
                if (Math.random() < CONFIG.MUTATION_ACTIVATION_RATE) {
                    let newAbility = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                    creature.specialAbilities[newAbility] = true;
                    
                    // Log with indication of positive/negative
                    const isNegative = negativeAbilities.includes(newAbility);
                    console.log(`${creature.type} gained ${isNegative ? 'NEGATIVE' : 'positive'} ability: ${newAbility}`);
                }
            }
        }

        // ===== WALL CLASS =====
        // Represents deadly obstacles in the environment
        class Wall {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.type = 'WALL';
            }

            // Draw the wall
            draw() {
                let pixelX = this.x * CONFIG.GRID_SIZE;
                let pixelY = this.y * CONFIG.GRID_SIZE;
                
                ctx.fillStyle = CONFIG.COLORS.WALL;
                ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                
                // Add danger indicator (red outline)
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(pixelX + 1, pixelY + 1, CONFIG.GRID_SIZE - 3, CONFIG.GRID_SIZE - 3);
            }
        }

        // ===== CREATURE CLASS =====
        // Represents individual creatures in the simulation
        class Creature {
            constructor(x, y, type = 'NEUTRAL') {
                // Position on the grid
                this.x = x || Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE));
                this.y = y || Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE));
                
                // Creature properties
                this.type = type;               // HUNTER, PREY, or NEUTRAL
                this.brain = new NeuralNetwork(); // The creature's neural network
                this.fitness = 0;               // How well this creature performs
                this.energy = CONFIG.STARTING_ENERGY; // Energy level (affects survival)
                this.age = 0;                   // How long the creature has lived
                
                // NEW: Elimination system
                this.isAlive = true;            // Whether creature is still active
                this.timesTagged = 0;           // How many times this creature was tagged
                this.eliminationReason = '';   // Why creature was eliminated
                
                // NEW: Special abilities system
                this.specialAbilities = {
                    // Hunter abilities
                    packHunting: false,         // See other hunters' targets
                    energyVampire: false,       // Drain more energy when tagging
                    wallBounce: false,          // Bounce off walls instead of taking damage
                    speedBurst: false,          // Temporary speed boost when low energy
                    territorialInstinct: false, // Gain energy when near other hunters
                    
                    // Prey abilities
                    camouflage: false,          // Harder to detect by hunters
                    evasion: false,             // Chance to avoid being tagged
                    energyEfficiency: false,    // Use less energy when moving
                    wallPhasing: false,         // Can pass through walls (limited uses)
                    groupHealing: false,        // Heal nearby prey more effectively
                    
                    // NEW: Negative mutations (can affect both types)
                    anxiety: false,             // Avoid being near others (blocks group healing)
                    aggression: false,          // Attack own type occasionally
                    paranoia: false,            // Constantly change direction, waste energy
                    lethargy: false,            // Move slower, use more energy
                    confusion: false            // Sometimes move in wrong direction
                };
                this.specialAbilityUses = {     // Limited-use abilities
                    wallPhasing: 3,             // Number of times can phase through walls
                    speedBurst: 5,              // Number of speed bursts available
                };
                this.abilityCountdown = {       // Cooldowns for abilities
                    speedBurst: 0,
                    camouflage: 0,
                };
                
                // Movement and behavior
                this.lastMove = { x: 0, y: 0 }; // Track movement for fitness
                this.tags = 0;                  // Number of successful tags
                this.timeAlive = 0;             // Survival time
                this.timeSinceLastTag = 0;      // Used for fitness calculation
                this.timesSurvived = 0;         // Frames survived without being tagged
                
                // Ensure starting position is not on a wall
                this.findSafeStartingPosition();
            }

            // NEW: Find a safe starting position (not on walls or other creatures)
            findSafeStartingPosition() {
                let attempts = 0;
                let maxAttempts = 100;
                
                while (attempts < maxAttempts) {
                    let testX = Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE));
                    let testY = Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE));
                    
                    if (this.isPositionSafe(testX, testY)) {
                        this.x = testX;
                        this.y = testY;
                        return;
                    }
                    attempts++;
                }
                
                // If no safe position found, use current position and hope for the best
                console.warn('Could not find safe starting position for creature');
            }

            // NEW: Check if a position is safe (no walls, no other creatures)
            isPositionSafe(x, y) {
                // Check boundaries
                if (x < 0 || x >= CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE ||
                    y < 0 || y >= CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE) {
                    return false;
                }
                
                // Check for walls
                for (let wall of walls) {
                    if (wall.x === x && wall.y === y) {
                        return false;
                    }
                }
                
                // Check for other creatures
                for (let creature of creatures) {
                    if (creature !== this && creature.isAlive && 
                        creature.x === x && creature.y === y) {
                        return false;
                    }
                }
                
                return true;
            }

            // Get sensory input from the environment
            getInputs() {
                let inputs = [];
                
                // Vision system - look in 8 directions around the creature
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],  // Top row
                    [0, -1],           [0, 1],    // Middle row (skip center)
                    [1, -1],  [1, 0],  [1, 1]    // Bottom row
                ];

                for (let dir of directions) {
                    let visionData = this.lookInDirection(dir[0], dir[1]);
                    
                    // Input represents what the creature sees in this direction
                    // 0 = wall/boundary, 0.5 = creature, 1 = empty space
                    inputs.push(visionData);
                }

                return inputs;
            }

            // NEW: Enhanced vision system that detects walls and creatures
            lookInDirection(dirX, dirY) {
                // Check each position in the direction up to vision range
                for (let distance = 1; distance <= CONFIG.VISION_RANGE; distance++) {
                    let checkX = this.x + (dirX * distance);
                    let checkY = this.y + (dirY * distance);
                    
                    // Check bounds
                    if (checkX < 0 || checkX >= CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE ||
                        checkY < 0 || checkY >= CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE) {
                        return 0; // Hit boundary
                    }
                    
                    // Check for walls (highest priority - danger!)
                    for (let wall of walls) {
                        if (wall.x === checkX && wall.y === checkY) {
                            return 0; // Wall detected
                        }
                    }
                    
                    // Check for other living creatures
                    for (let creature of creatures) {
                        if (creature !== this && creature.isAlive && 
                            creature.x === checkX && creature.y === checkY) {
                            
                            // Apply camouflage ability
                            if (creature.specialAbilities.camouflage && 
                                creature.abilityCountdown.camouflage > 0 && 
                                this.type === 'HUNTER') {
                                continue; // Camouflaged prey is invisible to hunters
                            }
                            
                            // Enhanced vision for pack hunting
                            if (this.specialAbilities.packHunting && 
                                this.type === 'HUNTER' && creature.type === 'PREY') {
                                return 0.9; // Enhanced target detection
                            }
                            
                            // Return different values based on creature type relationship
                            if (this.type === 'HUNTER' && creature.type === 'PREY') {
                                return 0.8; // Target found!
                            } else if (this.type === 'PREY' && creature.type === 'HUNTER') {
                                return 0.2; // Danger!
                            } else if (this.type === creature.type) {
                                return 0.6; // Same type - potential ally
                            } else {
                                return 0.5; // Neutral creature
                            }
                        }
                    }
                }
                
                return 1; // Clear path
            }

            // Make a decision about movement
            think() {
                // Only think if alive
                if (!this.isAlive) return;
                
                let inputs = this.getInputs();
                let outputs = this.brain.feedForward(inputs);
                
                // Outputs represent desire to move in each direction
                // [UP, DOWN, LEFT, RIGHT]
                let maxOutput = Math.max(...outputs);
                let chosenDirection = outputs.indexOf(maxOutput);
                
                // NEW: Apply negative mutation effects to decision making
                if (this.specialAbilities.confusion && Math.random() < 0.2) {
                    // 20% chance to move in wrong direction
                    chosenDirection = Math.floor(Math.random() * 4);
                }
                
                if (this.specialAbilities.paranoia && Math.random() < 0.3) {
                    // 30% chance to randomly change direction
                    chosenDirection = Math.floor(Math.random() * 4);
                }
                
                // Move based on the neural network's decision (potentially modified)
                this.move(chosenDirection);
            }

            // Move the creature in a chosen direction
            move(direction) {
                if (!this.isAlive) return;
                
                let newX = this.x;
                let newY = this.y;
                
                // Apply speed burst ability
                let moveDistance = 1;
                if (this.specialAbilities.speedBurst && 
                    this.energy < CONFIG.STARTING_ENERGY * 0.3 && 
                    this.specialAbilityUses.speedBurst > 0 &&
                    this.abilityCountdown.speedBurst === 0) {
                    moveDistance = 2;
                    this.specialAbilityUses.speedBurst--;
                    this.abilityCountdown.speedBurst = 30; // Cooldown
                    console.log(`${this.type} used speed burst!`);
                }
                
                // Calculate new position based on direction
                switch(direction) {
                    case 0: newY -= moveDistance; break; // UP
                    case 1: newY += moveDistance; break; // DOWN
                    case 2: newX -= moveDistance; break; // LEFT
                    case 3: newX += moveDistance; break; // RIGHT
                }
                
                // Check if the new position is safe
                if (this.isPositionSafe(newX, newY)) {
                    this.lastMove.x = newX - this.x;
                    this.lastMove.y = newY - this.y;
                    this.x = newX;
                    this.y = newY;
                    
                    // Calculate energy cost
                    let energyCost = CONFIG.ENERGY_MOVE_COST;
                    if (this.specialAbilities.energyEfficiency) {
                        energyCost *= 0.7; // 30% less energy usage
                    }
                    // NEW: Lethargy increases energy cost
                    if (this.specialAbilities.lethargy) {
                        energyCost *= 1.5; // 50% more energy usage
                    }
                    
                    this.energy -= energyCost;
                } else {
                    // Failed to move - check if it's because of a wall
                    if (!this.handleWallInteraction(newX, newY)) {
                        // Could not handle wall interaction
                    }
                }
                
                // Update creature state
                this.age++;
                this.timeAlive++;
                this.timeSinceLastTag++;
                this.timesSurvived++;
                
                // Update ability countdowns
                this.updateAbilityCooldowns();
                
                // Lose energy over time
                this.energy -= CONFIG.ENERGY_DECAY;
                
                // Apply special ability effects
                this.applyPassiveAbilities();
                
                // Check for elimination conditions
                this.checkElimination();
            }

            // NEW: Enhanced wall interaction with abilities
            handleWallInteraction(attemptedX, attemptedY) {
                for (let wall of walls) {
                    if (wall.x === attemptedX && wall.y === attemptedY) {
                        // Check for wall phasing ability
                        if (this.specialAbilities.wallPhasing && 
                            this.specialAbilityUses.wallPhasing > 0) {
                            this.specialAbilityUses.wallPhasing--;
                            this.x = attemptedX;
                            this.y = attemptedY;
                            console.log(`${this.type} phased through wall! Uses left: ${this.specialAbilityUses.wallPhasing}`);
                            return true;
                        }
                        
                        // Check for wall bounce ability
                        if (this.specialAbilities.wallBounce) {
                            // Bounce back to previous position with no damage
                            console.log(`${this.type} bounced off wall!`);
                            return true;
                        }
                        
                        // Normal wall collision - take damage
                        this.energy -= CONFIG.WALL_KILL_ENERGY;
                        console.log(`${this.type} creature hit wall! Energy: ${this.energy.toFixed(1)}`);
                        
                        // Add visual feedback for wall collision
                        this.lastWallHit = 10; // Frames to show damage effect
                        return false;
                    }
                }
                return true;
            }

            // NEW: Update ability cooldowns
            updateAbilityCooldowns() {
                Object.keys(this.abilityCountdown).forEach(ability => {
                    if (this.abilityCountdown[ability] > 0) {
                        this.abilityCountdown[ability]--;
                    }
                });
                
                // Activate camouflage periodically for prey
                if (this.specialAbilities.camouflage && 
                    this.type === 'PREY' && 
                    this.abilityCountdown.camouflage === 0 &&
                    Math.random() < 0.05) {
                    this.abilityCountdown.camouflage = 60; // Active for 60 frames
                }
            }

            // NEW: Apply passive special abilities
            applyPassiveAbilities() {
                // Territorial instinct for hunters
                if (this.specialAbilities.territorialInstinct && this.type === 'HUNTER') {
                    let nearbyHunters = creatures.filter(c => 
                        c !== this && c.isAlive && c.type === 'HUNTER' &&
                        Math.abs(c.x - this.x) <= 2 && Math.abs(c.y - this.y) <= 2
                    ).length;
                    this.energy += nearbyHunters * 0.2;
                }
                
                // Gain energy for surviving (if prey/hider)
                if (this.type === 'PREY' && this.timeSinceLastTag > 0) {
                    let survivalBonus = CONFIG.ENERGY_GAIN_SURVIVAL;
                    if (this.specialAbilities.energyEfficiency) {
                        survivalBonus *= 1.3; // 30% bonus
                    }
                    this.energy += survivalBonus;
                }
                
                // NEW: Apply negative mutation effects
                if (this.specialAbilities.paranoia) {
                    // Constantly changing direction wastes extra energy
                    this.energy -= 0.3;
                }
                
                if (this.specialAbilities.lethargy) {
                    // Uses more energy for all actions
                    this.energy -= 0.4;
                }
                
                if (this.specialAbilities.anxiety) {
                    // Loses energy when near others of same type
                    let nearbyOwnType = creatures.filter(c => 
                        c !== this && c.isAlive && c.type === this.type &&
                        Math.abs(c.x - this.x) <= 2 && Math.abs(c.y - this.y) <= 2
                    ).length;
                    this.energy -= nearbyOwnType * 0.5; // Penalty for being near others
                }
            }

            // NEW: Check if creature should be eliminated
            checkElimination() {
                if (!this.isAlive) return;
                
                // Check energy death
                if (this.energy <= CONFIG.ENERGY_DEATH_THRESHOLD) {
                    this.eliminate('Energy Depleted');
                    return;
                }
                
                // Check tag limit
                if (this.timesTagged >= CONFIG.MAX_TAGS_BEFORE_OUT) {
                    this.eliminate('Tagged Out');
                    return;
                }
                
                // Keep energy within reasonable bounds
                this.energy = Math.max(0, Math.min(CONFIG.STARTING_ENERGY * 1.5, this.energy));
            }

            // NEW: Eliminate creature from simulation
            eliminate(reason) {
                this.isAlive = false;
                this.eliminationReason = reason;
                console.log(`${this.type} creature eliminated: ${reason}`);
            }

            // Calculate fitness based on the current game mode
            calculateFitness() {
                // Base fitness starts with survival time
                let baseFitness = this.timeAlive * 1.0;
                
                switch(gameMode) {
                    case 'tag':
                        if (this.type === 'HUNTER') {
                            // Hunters rewarded for tags, survival, and movement
                            this.fitness = baseFitness + 
                                          (this.tags * 150) + 
                                          (this.energy * 0.5) +
                                          (Math.abs(this.lastMove.x) + Math.abs(this.lastMove.y)) * 2.0;
                        } else {
                            // Prey rewarded for survival, avoiding tags, maintaining energy
                            this.fitness = baseFitness * 2.0 + 
                                          (this.energy * 1.0) +
                                          (this.timesSurvived * 0.5) -
                                          (this.timesTagged * 100);
                        }
                        break;
                        
                    case 'hideSeek':
                        if (this.type === 'PREY') {
                            // Prey tries to hide and survive
                            this.fitness = baseFitness * 1.5 + 
                                          (this.getAverageDistanceToHunters() * 20) +
                                          (this.energy * 1.0) +
                                          (this.timesSurvived * 1.0);
                        } else {
                            // Hunters try to find and tag prey
                            this.fitness = baseFitness + 
                                          (this.tags * 200) + 
                                          (this.energy * 0.5);
                        }
                        break;
                        
                    case 'mixed':
                        // Balanced fitness for exploration, survival, and interaction
                        this.fitness = baseFitness + 
                                      (this.tags * 100) + 
                                      (this.energy * 0.8) +
                                      (this.timesSurvived * 0.3) +
                                      (Math.abs(this.lastMove.x) + Math.abs(this.lastMove.y)) * 1.5;
                        break;
                }
                
                // Bonus for being alive
                if (this.isAlive) {
                    this.fitness += 50;
                }
                
                // Penalty for elimination
                if (!this.isAlive) {
                    if (this.eliminationReason === 'Energy Depleted') {
                        this.fitness *= 0.5; // Heavy penalty for poor energy management
                    } else if (this.eliminationReason === 'Tagged Out') {
                        this.fitness *= 0.7; // Moderate penalty for being caught
                    }
                }
                
                // Ensure fitness is never negative
                this.fitness = Math.max(0, this.fitness);
            }

            // Helper function to calculate average distance to hunters specifically
            getAverageDistanceToHunters() {
                let hunters = creatures.filter(c => c.type === 'HUNTER' && c.isAlive && c !== this);
                if (hunters.length === 0) return 10; // Max distance if no hunters
                
                let totalDistance = 0;
                for (let hunter of hunters) {
                    let distance = Math.sqrt(
                        Math.pow(this.x - hunter.x, 2) + 
                        Math.pow(this.y - hunter.y, 2)
                    );
                    totalDistance += distance;
                }
                
                return totalDistance / hunters.length;
            }

            // Check for tagging with other creatures
            checkForTags() {
                if (!this.isAlive) return;
                
                for (let other of creatures) {
                    if (other !== this && other.isAlive) {
                        let distance = Math.sqrt(
                            Math.pow(this.x - other.x, 2) + 
                            Math.pow(this.y - other.y, 2)
                        );
                        
                        if (distance <= CONFIG.TAG_DISTANCE) {
                            // NEW: Aggression mutation - attack own type occasionally
                            if (this.specialAbilities.aggression && this.type === other.type && 
                                Math.random() < 0.1) {
                                // Aggressive creature "tags" its own type, causing damage
                                other.energy -= 10;
                                this.energy -= 5; // Aggressor also loses some energy
                                console.log(`${this.type} creature attacked own type due to aggression!`);
                                return;
                            }
                            
                            // Check for same-type cooperative healing
                            if (this.type === other.type && 
                                (this.timesTagged > 0 || other.timesTagged > 0) &&
                                Math.random() < CONFIG.SAME_TYPE_HEAL_CHANCE) {
                                this.performCooperativeHealing(other);
                                return;
                            }
                            
                            // Hunter tagging prey
                            if (this.type === 'HUNTER' && other.type === 'PREY') {
                                // Check for evasion ability
                                if (other.specialAbilities.evasion && Math.random() < 0.3) {
                                    console.log(`Prey evaded hunter's tag!`);
                                    return;
                                }
                                
                                // Successful tag
                                this.tags++;
                                other.timesTagged++;
                                this.timeSinceLastTag = 0;
                                other.timeSinceLastTag = 0;
                                
                                // Calculate energy transfer
                                let energyGain = CONFIG.ENERGY_GAIN_TAG;
                                let energyLoss = CONFIG.ENERGY_GAIN_TAG * 0.5;
                                
                                // Energy vampire ability
                                if (this.specialAbilities.energyVampire) {
                                    energyGain *= 1.5;
                                    energyLoss *= 1.2;
                                }
                                
                                this.energy += energyGain;
                                other.energy -= energyLoss;
                                
                                stats.tags++;
                                console.log(`Hunter tagged prey! Hunter energy: ${this.energy.toFixed(1)}, Prey energy: ${other.energy.toFixed(1)}, Prey tags: ${other.timesTagged}`);
                            }
                        }
                    }
                }
            }

            // NEW: Cooperative healing between same-type creatures
            performCooperativeHealing(other) {
                // NEW: Anxiety blocks cooperative healing
                if (this.specialAbilities.anxiety || other.specialAbilities.anxiety) {
                    return; // Anxious creatures won't heal or be healed
                }
                
                if (this.energy < CONFIG.HEAL_ENERGY_COST && 
                    other.energy < CONFIG.HEAL_ENERGY_COST) {
                    return; // Not enough energy for either to heal
                }
                
                let healer = this.energy > other.energy ? this : other;
                let patient = healer === this ? other : this;
                
                if (patient.timesTagged > 0) {
                    // Remove one tag from the patient
                    patient.timesTagged--;
                    healer.energy -= CONFIG.HEAL_ENERGY_COST;
                    
                    // Group healing ability bonus
                    if (healer.specialAbilities.groupHealing) {
                        patient.energy += 10; // Bonus healing
                        console.log(`Enhanced group healing performed!`);
                    }
                    
                    console.log(`${healer.type} healed ${patient.type}! Patient tags: ${patient.timesTagged}, Healer energy: ${healer.energy.toFixed(1)}`);
                    
                    // Visual feedback
                    healer.lastHeal = 20;
                    patient.lastHealed = 20;
                }
            }

            // Draw the creature on the canvas
            draw() {
                if (!this.isAlive) {
                    // Draw eliminated creatures as faded ghosts
                    this.drawEliminated();
                    return;
                }
                
                let pixelX = this.x * CONFIG.GRID_SIZE;
                let pixelY = this.y * CONFIG.GRID_SIZE;
                
                // Choose color based on type
                let color = CONFIG.COLORS[this.type];
                
                // Transparency based on energy level
                let alpha = Math.max(0.3, this.energy / CONFIG.STARTING_ENERGY);
                
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                
                // Draw the creature as a square
                ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                
                // Energy bar
                this.drawEnergyBar(pixelX, pixelY);
                
                // Wall collision effect
                if (this.lastWallHit && this.lastWallHit > 0) {
                    ctx.fillStyle = '#ff0000';
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                    this.lastWallHit--;
                }
                
                // Healing effect
                if (this.lastHeal && this.lastHeal > 0) {
                    ctx.fillStyle = '#00ff00';
                    ctx.globalAlpha = 0.6;
                    ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                    this.lastHeal--;
                }
                
                // Being healed effect
                if (this.lastHealed && this.lastHealed > 0) {
                    ctx.fillStyle = '#00ffff';
                    ctx.globalAlpha = 0.4;
                    ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                    this.lastHealed--;
                }
                
                // Camouflage effect
                if (this.specialAbilities.camouflage && this.abilityCountdown.camouflage > 0) {
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.3; // Very transparent when camouflaged
                    ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                }
                
                // Tag indicator (if recently tagged)
                if (this.timesTagged > 0 && this.timeSinceLastTag < 30) {
                    ctx.fillStyle = '#ffff00';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(pixelX + 2, pixelY + 2, CONFIG.GRID_SIZE - 5, CONFIG.GRID_SIZE - 5);
                }
                
                // Special ability indicators
                this.drawAbilityIndicators(pixelX, pixelY);
                
                ctx.globalAlpha = 1.0;
            }

            // NEW: Draw special ability indicators
            drawAbilityIndicators(x, y) {
                let indicatorSize = 3;
                let offsetY = 0;
                
                // Active abilities get small colored dots
                if (this.specialAbilities.packHunting && this.type === 'HUNTER') {
                    ctx.fillStyle = '#ff8800';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(x + CONFIG.GRID_SIZE - 5, y + offsetY, indicatorSize, indicatorSize);
                    offsetY += 4;
                }
                
                if (this.specialAbilities.camouflage && this.abilityCountdown.camouflage > 0) {
                    ctx.fillStyle = '#8800ff';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(x + CONFIG.GRID_SIZE - 5, y + offsetY, indicatorSize, indicatorSize);
                    offsetY += 4;
                }
                
                if (this.specialAbilities.wallPhasing && this.specialAbilityUses.wallPhasing > 0) {
                    ctx.fillStyle = '#00ff88';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(x + CONFIG.GRID_SIZE - 5, y + offsetY, indicatorSize, indicatorSize);
                    offsetY += 4;
                }
                
                if (this.specialAbilities.speedBurst && this.specialAbilityUses.speedBurst > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(x + CONFIG.GRID_SIZE - 5, y + offsetY, indicatorSize, indicatorSize);
                }
            }

            // NEW: Draw energy bar above creature
            drawEnergyBar(x, y) {
                let barWidth = CONFIG.GRID_SIZE - 4;
                let barHeight = 3;
                let energyPercentage = Math.max(0, this.energy / CONFIG.STARTING_ENERGY);
                
                // Background
                ctx.fillStyle = '#333333';
                ctx.globalAlpha = 0.8;
                ctx.fillRect(x + 2, y - 6, barWidth, barHeight);
                
                // Energy fill
                if (energyPercentage > 0.6) {
                    ctx.fillStyle = '#00ff00';
                } else if (energyPercentage > 0.3) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = '#ff0000';
                }
                
                ctx.fillRect(x + 2, y - 6, barWidth * energyPercentage, barHeight);
            }

            // NEW: Draw eliminated creatures
            drawEliminated() {
                let pixelX = this.x * CONFIG.GRID_SIZE;
                let pixelY = this.y * CONFIG.GRID_SIZE;
                
                // Draw as gray ghost
                ctx.fillStyle = '#666666';
                ctx.globalAlpha = 0.2;
                ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                
                // Draw X to show elimination
                ctx.strokeStyle = '#ff0000';
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pixelX + 2, pixelY + 2);
                ctx.lineTo(pixelX + CONFIG.GRID_SIZE - 3, pixelY + CONFIG.GRID_SIZE - 3);
                ctx.moveTo(pixelX + CONFIG.GRID_SIZE - 3, pixelY + 2);
                ctx.lineTo(pixelX + 2, pixelY + CONFIG.GRID_SIZE - 3);
                ctx.stroke();
                
                ctx.globalAlpha = 1.0;
            }
        }

        // ===== GENETIC ALGORITHM FUNCTIONS =====
        // These functions handle evolution between generations

        // Create the next generation through evolution
        function evolvePopulation() {
            // Calculate fitness for all creatures
            creatures.forEach(creature => creature.calculateFitness());
            
            // Sort by fitness (highest first)
            creatures.sort((a, b) => b.fitness - a.fitness);
            
            // Update statistics
            updateStats();
            
            // NEW: Count current population balance
            let hunterCount = creatures.filter(c => c.type === 'HUNTER').length;
            let preyCount = creatures.filter(c => c.type === 'PREY').length;
            
            console.log(`Pre-evolution: ${hunterCount} hunters, ${preyCount} prey`);
            
            let newPopulation = [];
            let eliteCount = Math.floor(CONFIG.POPULATION_SIZE * CONFIG.ELITE_PERCENTAGE);
            
            // Keep the best performers (elitism)
            for (let i = 0; i < eliteCount && i < creatures.length; i++) {
                let elite = new Creature(
                    Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE - 2)) + 1,
                    Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE - 2)) + 1,
                    creatures[i].type
                );
                elite.brain = creatures[i].brain.copy();
                // Copy special abilities
                Object.keys(creatures[i].specialAbilities).forEach(ability => {
                    elite.specialAbilities[ability] = creatures[i].specialAbilities[ability];
                });
                newPopulation.push(elite);
            }
            
            // NEW: Enforce population balance for remaining slots
            let targetHunters = Math.floor(CONFIG.POPULATION_SIZE / 2);
            let targetPrey = CONFIG.POPULATION_SIZE - targetHunters;
            let currentHunters = newPopulation.filter(c => c.type === 'HUNTER').length;
            let currentPrey = newPopulation.filter(c => c.type === 'PREY').length;
            
            // Create offspring for the rest of the population with type enforcement
            while (newPopulation.length < CONFIG.POPULATION_SIZE) {
                // Select two parents using tournament selection
                let parent1 = tournamentSelection();
                let parent2 = tournamentSelection();
                
                // Determine child type based on what's needed
                let childType;
                if (currentHunters < targetHunters) {
                    childType = 'HUNTER';
                    currentHunters++;
                } else if (currentPrey < targetPrey) {
                    childType = 'PREY';
                    currentPrey++;
                } else {
                    // Fallback to random if somehow balanced
                    childType = Math.random() < 0.5 ? 'HUNTER' : 'PREY';
                }
                
                // Create child
                let child = new Creature(
                    Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE - 2)) + 1,
                    Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE - 2)) + 1,
                    childType
                );
                
                // Crossover (combine parent brains)
                if (Math.random() < CONFIG.CROSSOVER_RATE) {
                    child.brain = crossover(parent1.brain, parent2.brain);
                } else {
                    child.brain = parent1.brain.copy();
                }
                
                // Mutate the child
                child.brain.mutate(CONFIG.MUTATION_RATE);
                
                // NEW: Mutate special abilities
                child.brain.mutateSpecialAbilities(child);
                
                newPopulation.push(child);
            }
            
            // Replace old population
            creatures = newPopulation;
            generation++;
            frameCount = 0;
            stats.tags = 0;
            
            // Reset simulation timer
            simulationStartTime = Date.now();
            simulationPausedTime = 0;
            
            // Verify final balance
            let finalHunters = creatures.filter(c => c.type === 'HUNTER').length;
            let finalPrey = creatures.filter(c => c.type === 'PREY').length;
            console.log(`Generation ${generation} - Hunters: ${finalHunters}, Prey: ${finalPrey}, Best Fitness: ${stats.bestFitness.toFixed(2)}`);
        }

        // Tournament selection - pick the best from a random group
        function tournamentSelection() {
            let tournamentSize = 5;
            let tournament = [];
            
            for (let i = 0; i < tournamentSize; i++) {
                tournament.push(creatures[Math.floor(Math.random() * creatures.length)]);
            }
            
            tournament.sort((a, b) => b.fitness - a.fitness);
            return tournament[0];
        }

        // Crossover - combine two neural networks
        function crossover(brain1, brain2) {
            // Choose the parent with more hidden nodes as the base
            let baseBrain = brain1.hiddenNodeCount >= brain2.hiddenNodeCount ? brain1 : brain2;
            let otherBrain = baseBrain === brain1 ? brain2 : brain1;
            
            let child = new NeuralNetwork(baseBrain.hiddenNodeCount);
            
            // Crossover input to hidden weights
            for (let i = 0; i < CONFIG.INPUT_NODES; i++) {
                for (let j = 0; j < child.hiddenNodeCount; j++) {
                    if (j < otherBrain.hiddenNodeCount) {
                        // Both parents have this connection
                        child.inputToHidden[i][j] = Math.random() < 0.5 ? 
                            baseBrain.inputToHidden[i][j] : otherBrain.inputToHidden[i][j];
                    } else {
                        // Only base parent has this connection
                        child.inputToHidden[i][j] = baseBrain.inputToHidden[i][j];
                    }
                }
            }
            
            // Crossover hidden to output weights
            for (let i = 0; i < child.hiddenNodeCount; i++) {
                for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                    if (i < otherBrain.hiddenNodeCount) {
                        // Both parents have this connection
                        child.hiddenToOutput[i][j] = Math.random() < 0.5 ? 
                            baseBrain.hiddenToOutput[i][j] : otherBrain.hiddenToOutput[i][j];
                    } else {
                        // Only base parent has this connection
                        child.hiddenToOutput[i][j] = baseBrain.hiddenToOutput[i][j];
                    }
                }
            }
            
            // Crossover biases
            for (let i = 0; i < child.hiddenNodeCount; i++) {
                if (i < otherBrain.hiddenNodeCount) {
                    child.hiddenBias[i] = Math.random() < 0.5 ? 
                        baseBrain.hiddenBias[i] : otherBrain.hiddenBias[i];
                } else {
                    child.hiddenBias[i] = baseBrain.hiddenBias[i];
                }
            }
            
            for (let i = 0; i < CONFIG.OUTPUT_NODES; i++) {
                child.outputBias[i] = Math.random() < 0.5 ? 
                    baseBrain.outputBias[i] : otherBrain.outputBias[i];
            }
            
            return child;
        }

        // ===== SIMULATION FUNCTIONS =====

        // Initialize the simulation
        function init() {
            // Set up canvas
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CONFIG.CANVAS_WIDTH;
            canvas.height = CONFIG.CANVAS_HEIGHT;
            
            // NEW: Initialize timer
            simulationStartTime = Date.now();
            simulationPausedTime = 0;
            lastPauseStart = 0;
            
            // Create initial population
            createInitialPopulation();
            
            // Set up event listeners
            setupEventListeners();
            
            // Start the main game loop
            gameLoop();
        }

        // Create the initial population of creatures
        function createInitialPopulation() {
            creatures = [];
            
            // Create walls first
            createWalls();
            
            for (let i = 0; i < CONFIG.POPULATION_SIZE; i++) {
                let type;
                
                // Assign creature types based on game mode
                switch(gameMode) {
                    case 'tag':
                        type = i < CONFIG.POPULATION_SIZE / 2 ? 'HUNTER' : 'PREY';
                        break;
                    case 'hideSeek':
                        type = i < CONFIG.POPULATION_SIZE * 0.2 ? 'HUNTER' : 'PREY';
                        break;
                    case 'mixed':
                        if (i < CONFIG.POPULATION_SIZE * 0.3) type = 'HUNTER';
                        else if (i < CONFIG.POPULATION_SIZE * 0.6) type = 'PREY';
                        else type = 'NEUTRAL';
                        break;
                }
                
                let creature = new Creature(undefined, undefined, type);
                creatures.push(creature);
            }
        }

        // NEW: Create walls in the environment
        function createWalls() {
            walls = [];
            let gridWidth = Math.floor(CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE);
            let gridHeight = Math.floor(CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE);
            
            // NEW: Create boundary walls (one square thick around the edge)
            // Top and bottom boundaries
            for (let x = 0; x < gridWidth; x++) {
                walls.push(new Wall(x, 0));                    // Top boundary
                walls.push(new Wall(x, gridHeight - 1));       // Bottom boundary
            }
            
            // Left and right boundaries (excluding corners already covered)
            for (let y = 1; y < gridHeight - 1; y++) {
                walls.push(new Wall(0, y));                    // Left boundary
                walls.push(new Wall(gridWidth - 1, y));        // Right boundary
            }
            
            // Add random internal walls
            let totalCells = gridWidth * gridHeight;
            let wallCount = Math.floor(totalCells * CONFIG.WALL_DENSITY);
            
            for (let i = 0; i < wallCount; i++) {
                // Only place internal walls (not on boundaries)
                let x = Math.floor(Math.random() * (gridWidth - 2)) + 1;
                let y = Math.floor(Math.random() * (gridHeight - 2)) + 1;
                
                // Make sure we don't place walls on top of each other
                let wallExists = walls.some(wall => wall.x === x && wall.y === y);
                if (!wallExists) {
                    walls.push(new Wall(x, y));
                }
            }
            
            console.log(`Created ${walls.length} walls (including boundary)`);
        }

        // Main game loop
        function gameLoop() {
            if (!isPaused && !turboModeActive) {
                update();
                draw();
                
                frameCount++;
                
                // Check if it's time to evolve
                if (frameCount >= CONFIG.GENERATION_LENGTH) {
                    evolvePopulation();
                }
            }
            
            // Continue the loop (but don't update display during turbo mode)
            requestAnimationFrame(gameLoop);
        }

        // Update all creatures
        function update() {
            let aliveCreatures = creatures.filter(c => c.isAlive);
            
            // Update only living creatures
            aliveCreatures.forEach(creature => {
                creature.think();
                creature.checkForTags();
                creature.calculateFitness();
            });
            
            // Update statistics
            stats.aliveCount = aliveCreatures.length;
            stats.eliminatedCount = creatures.length - aliveCreatures.length;
            
            // Check if we need to evolve early (if too few creatures alive)
            if (aliveCreatures.length < CONFIG.POPULATION_SIZE * 0.1) {
                console.log('Most creatures eliminated, forcing evolution...');
                evolvePopulation();
            }
            
            // Update UI
            updateDisplay();
        }

        // Draw everything
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid (optional)
            drawGrid();
            
            // Draw walls first
            walls.forEach(wall => wall.draw());
            
            // Draw all creatures (living and eliminated)
            creatures.forEach(creature => creature.draw());
        }

        // Draw grid lines (helpful for visualization)
        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 0.5;
            
            // Vertical lines
            for (let x = 0; x < canvas.width; x += CONFIG.GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y < canvas.height; y += CONFIG.GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Update statistics
        function updateStats() {
            if (creatures.length > 0) {
                stats.bestFitness = Math.max(...creatures.map(c => c.fitness));
                stats.avgFitness = creatures.reduce((sum, c) => sum + c.fitness, 0) / creatures.length;
            }
        }

        // Update the display elements
        function updateDisplay() {
            document.getElementById('generation').textContent = generation;
            document.getElementById('bestFitness').textContent = stats.bestFitness.toFixed(2);
            document.getElementById('aliveCount').textContent = stats.aliveCount;
            document.getElementById('eliminatedCount').textContent = stats.eliminatedCount;
            
            // Count active abilities
            let totalAbilities = creatures.reduce((sum, creature) => {
                return sum + Object.values(creature.specialAbilities).filter(Boolean).length;
            }, 0);
            document.getElementById('abilityCount').textContent = totalAbilities;

            // NEW: Calculate neural network diversity
            let hiddenNodeCounts = {};
            creatures.forEach(creature => {
                let count = creature.brain.hiddenNodeCount;
                hiddenNodeCounts[count] = (hiddenNodeCounts[count] || 0) + 1;
            });
            document.getElementById('neuralDiversity').textContent = Object.keys(hiddenNodeCounts).length;
            document.getElementById('topologyChanges').textContent = turboStats.topologyChanges;

            // NEW: Update simulation timer
            if (CONFIG.SHOW_TIMER && simulationStartTime > 0) {
                let currentTime = Date.now();
                let elapsedTime = currentTime - simulationStartTime - simulationPausedTime;
                if (isPaused) {
                    elapsedTime -= currentTime - lastPauseStart;
                }
                
                let seconds = Math.floor(elapsedTime / 1000) % 60;
                let minutes = Math.floor(elapsedTime / 60000);
                let timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('simulationTimer').textContent = `Time: ${timeString}`;
            }

            // Update analytics panel every few frames to avoid performance issues
            if (frameCount % 30 === 0) {
                updateAnalytics();
                
                // Update neural network visualizations
                const bestHunter = creatures
                    .filter(c => c.type === 'HUNTER' && c.isAlive)
                    .sort((a, b) => b.fitness - a.fitness)[0];
                const bestPrey = creatures
                    .filter(c => c.type === 'PREY' && c.isAlive)
                    .sort((a, b) => b.fitness - a.fitness)[0];
                
                if (bestHunter) drawNeuralNetwork('hunterBrain', bestHunter);
                if (bestPrey) drawNeuralNetwork('preyBrain', bestPrey);
            }
        }

        // ===== EVENT LISTENERS =====
        function setupEventListeners() {
            // Population size control
            document.getElementById('populationSize').addEventListener('input', function(e) {
                CONFIG.POPULATION_SIZE = parseInt(e.target.value);
                document.getElementById('popDisplay').textContent = e.target.value;
            });

            // Simulation speed control
            document.getElementById('simSpeed').addEventListener('input', function(e) {
                let speedMultiplier = parseFloat(e.target.value);
                CONFIG.GENERATION_LENGTH = Math.floor(3000 / speedMultiplier);
                document.getElementById('speedDisplay').textContent = speedMultiplier + 'x';
                
                // For very high speeds, adjust frame skipping in game loop
                if (speedMultiplier > 10) {
                    document.getElementById('speedDisplay').textContent = speedMultiplier + 'x (Fast Mode)';
                }
            });

            // NEW: Timer toggle control
            document.getElementById('showTimer').addEventListener('change', function(e) {
                CONFIG.SHOW_TIMER = e.target.checked;
                document.getElementById('simulationTimer').style.display = CONFIG.SHOW_TIMER ? 'block' : 'none';
            });

            // Mutation rate control
            document.getElementById('mutationRate').addEventListener('input', function(e) {
                CONFIG.MUTATION_RATE = parseFloat(e.target.value);
                document.getElementById('mutationDisplay').textContent = e.target.value;
            });

            // Grid size control
            document.getElementById('gridSize').addEventListener('input', function(e) {
                CONFIG.GRID_SIZE = parseInt(e.target.value);
                document.getElementById('gridDisplay').textContent = e.target.value;
                
                // Recreate walls with new grid size
                createWalls();
                
                // Reposition creatures to ensure they're still in valid positions
                creatures.forEach(creature => {
                    creature.findSafeStartingPosition();
                });
                
                console.log(`Grid size changed to ${CONFIG.GRID_SIZE}, walls and creatures repositioned`);
            });

            // NEW: Wall density control
            document.getElementById('wallDensity').addEventListener('input', function(e) {
                CONFIG.WALL_DENSITY = parseFloat(e.target.value) / 100;
                document.getElementById('wallDisplay').textContent = e.target.value + '%';
            });

            // NEW: Ability mutation rate control
            document.getElementById('abilityMutation').addEventListener('input', function(e) {
                CONFIG.MUTATION_ACTIVATION_RATE = parseFloat(e.target.value) / 100;
                document.getElementById('abilityMutationDisplay').textContent = e.target.value + '%';
            });

            // Game mode selection
            document.getElementById('gameMode').addEventListener('change', function(e) {
                gameMode = e.target.value;
                createInitialPopulation(); // Restart with new mode
                generation = 1;
                frameCount = 0;
            });

            // Control buttons
            document.getElementById('pauseBtn').addEventListener('click', function() {
                if (!isPaused) {
                    lastPauseStart = Date.now();
                } else {
                    simulationPausedTime += Date.now() - lastPauseStart;
                }
                isPaused = !isPaused;
                this.textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            });

            document.getElementById('resetBtn').addEventListener('click', function() {
                createInitialPopulation();
                generation = 1;
                frameCount = 0;
                stats.tags = 0;
                stats.aliveCount = 0;
                stats.eliminatedCount = 0;
                // Reset timer
                simulationStartTime = Date.now();
                simulationPausedTime = 0;
                lastPauseStart = 0;
            });

            document.getElementById('evolveBtn').addEventListener('click', function() {
                evolvePopulation();
            });

            // NEW: Turbo mode controls
            document.getElementById('turboBtn').addEventListener('click', function() {
                toggleTurboMode();
            });

            document.getElementById('turboGenerations').addEventListener('input', function(e) {
                CONFIG.TURBO_GENERATIONS = parseInt(e.target.value);
                document.getElementById('turboGenDisplay').textContent = e.target.value;
            });

            // Resize canvas when window resizes
            window.addEventListener('resize', function() {
                CONFIG.CANVAS_WIDTH = window.innerWidth;
                CONFIG.CANVAS_HEIGHT = window.innerHeight;
                canvas.width = CONFIG.CANVAS_WIDTH;
                canvas.height = CONFIG.CANVAS_HEIGHT;
            });

            // Initialize panel states (all collapsed by default except main controls)
            togglePanel('info-panel');
            togglePanel('analytics-panel'); 
            togglePanel('neural-viz-panel');
        }

        // ===== NEW UI FUNCTIONS =====
        // NEW: Turbo Evolution Mode
        function toggleTurboMode() {
            if (turboModeActive) {
                // Stop turbo mode
                turboModeActive = false;
                turboGenerationsLeft = 0;
                document.getElementById('turboBtn').textContent = 'üöÄ Turbo Mode';
                document.getElementById('turboBtn').classList.remove('active');
                document.getElementById('turboControls').style.display = 'none';
                document.getElementById('turboStatus').textContent = '';
                console.log('Turbo mode stopped');
            } else {
                // Start turbo mode
                if (isPaused) {
                    alert('Please unpause the simulation before starting turbo mode');
                    return;
                }
                
                turboModeActive = true;
                turboGenerationsLeft = CONFIG.TURBO_GENERATIONS;
                turboStats.startGeneration = generation;
                turboStats.bestFitnessHistory = [];
                turboStats.avgFitnessHistory = [];
                turboStats.topologyChanges = 0;
                
                document.getElementById('turboBtn').textContent = '‚èπÔ∏è Stop Turbo';
                document.getElementById('turboBtn').classList.add('active');
                document.getElementById('turboControls').style.display = 'block';
                
                console.log(`Turbo mode started: ${CONFIG.TURBO_GENERATIONS} generations`);
                
                // Start the turbo evolution loop
                runTurboEvolution();
            }
        }

        // Run turbo evolution without visual updates
        function runTurboEvolution() {
            if (!turboModeActive || turboGenerationsLeft <= 0) {
                // Turbo mode complete
                finishTurboMode();
                return;
            }

            // Update status
            document.getElementById('turboStatus').textContent = 
                `Running... ${CONFIG.TURBO_GENERATIONS - turboGenerationsLeft + 1}/${CONFIG.TURBO_GENERATIONS}`;

            // Run one generation quickly
            let generationsThisRound = Math.min(5, turboGenerationsLeft); // Process 5 generations at a time
            
            for (let i = 0; i < generationsThisRound; i++) {
                // Fast evolution without visual updates
                runFastGeneration();
                turboGenerationsLeft--;
                
                // Record statistics every 10 generations
                if ((CONFIG.TURBO_GENERATIONS - turboGenerationsLeft) % CONFIG.TURBO_STATS_INTERVAL === 0) {
                    turboStats.bestFitnessHistory.push(stats.bestFitness);
                    turboStats.avgFitnessHistory.push(stats.avgFitness);
                }
            }

            // Continue on next frame
            if (turboModeActive && turboGenerationsLeft > 0) {
                requestAnimationFrame(runTurboEvolution);
            } else {
                finishTurboMode();
            }
        }

        // Run a single generation at high speed without visual updates
        function runFastGeneration() {
            // Simulate creatures without drawing
            for (let frame = 0; frame < CONFIG.GENERATION_LENGTH; frame++) {
                creatures.forEach(creature => {
                    if (creature.isAlive) {
                        creature.think();
                        creature.checkForTags();
                    }
                });
            }
            
            // Evolve population
            evolvePopulation();
        }

        // Finish turbo mode and show results
        function finishTurboMode() {
            turboModeActive = false;
            document.getElementById('turboBtn').textContent = 'üöÄ Turbo Mode';
            document.getElementById('turboBtn').classList.remove('active');
            
            // Calculate results
            let finalGeneration = generation;
            let generationsRun = finalGeneration - turboStats.startGeneration;
            let bestImprovement = turboStats.bestFitnessHistory.length > 0 ? 
                Math.max(...turboStats.bestFitnessHistory) - turboStats.bestFitnessHistory[0] : 0;
            
            // Count current neural network diversity
            let hiddenNodeCounts = {};
            creatures.forEach(creature => {
                let count = creature.brain.hiddenNodeCount;
                hiddenNodeCounts[count] = (hiddenNodeCounts[count] || 0) + 1;
            });
            
            let diversity = Object.keys(hiddenNodeCounts).length;
            
            // Show results
            let resultsMessage = `üöÄ TURBO MODE COMPLETE! üöÄ\n\n` +
                `üìä Results:\n` +
                `‚Ä¢ Generations evolved: ${generationsRun}\n` +
                `‚Ä¢ Fitness improvement: ${bestImprovement.toFixed(2)}\n` +
                `‚Ä¢ Topology changes: ${turboStats.topologyChanges}\n` +
                `‚Ä¢ Neural diversity: ${diversity} different network sizes\n` +
                `‚Ä¢ Network size range: ${Math.min(...Object.keys(hiddenNodeCounts))} - ${Math.max(...Object.keys(hiddenNodeCounts))} nodes\n\n` +
                `üß¨ The simulation is now ready at generation ${finalGeneration}!`;
            
            document.getElementById('turboStatus').innerHTML = resultsMessage.replace(/\n/g, '<br>');
            
            console.log('Turbo mode completed:', {
                generationsRun,
                bestImprovement,
                topologyChanges: turboStats.topologyChanges,
                neuralDiversity: diversity,
                hiddenNodeDistribution: hiddenNodeCounts
            });
        }
        // Toggle collapsible panels
        function togglePanel(panelId) {
            const content = document.getElementById(panelId + '-content');
            const arrow = document.getElementById(panelId + '-arrow');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                arrow.textContent = '‚ñ∂';
            }
        }

        // Update analytics panel with mutation statistics
        function updateAnalytics() {
            // Count ability occurrences
            const abilityStats = {
                // Hunter abilities
                packHunting: 0,
                energyVampire: 0,
                wallBounce: 0,
                speedBurst: 0,
                territorial: 0,
                // Prey abilities  
                camouflage: 0,
                evasion: 0,
                energyEfficient: 0,
                wallPhasing: 0,
                groupHealing: 0,
                // NEW: Negative mutations
                anxiety: 0,
                aggression: 0,
                paranoia: 0,
                lethargy: 0,
                confusion: 0
            };

            // Count current abilities in population
            creatures.forEach(creature => {
                Object.keys(creature.specialAbilities).forEach(ability => {
                    if (creature.specialAbilities[ability] && abilityStats.hasOwnProperty(ability)) {
                        abilityStats[ability]++;
                    }
                });
            });

            // Generate HTML for mutation stats
            let statsHTML = '<div class="mutation-grid">';
            Object.entries(abilityStats).forEach(([ability, count]) => {
                const percentage = creatures.length > 0 ? Math.round((count / creatures.length) * 100) : 0;
                const abilityName = ability.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                statsHTML += `<div class="stat-item">${abilityName}: ${count} (${percentage}%)</div>`;
            });
            statsHTML += '</div>';

            document.getElementById('mutationStats').innerHTML = statsHTML;

            // Update top performers
            const sortedCreatures = [...creatures]
                .filter(c => !c.eliminated)
                .sort((a, b) => b.fitness - a.fitness);
            
            let topHTML = '';
            for (let i = 0; i < Math.min(3, sortedCreatures.length); i++) {
                const creature = sortedCreatures[i];
                const abilities = Object.keys(creature.specialAbilities)
                    .filter(ability => creature.specialAbilities[ability])
                    .map(ability => ability.replace(/([A-Z])/g, ' $1'))
                    .join(', ');
                
                topHTML += `<div class="top-performer">
                    #${i+1} ${creature.type}: Fitness ${creature.fitness.toFixed(1)}<br>
                    <span style="color: #888;">${abilities || 'No special abilities'}</span>
                </div>`;
            }

            document.getElementById('topPerformers').innerHTML = topHTML;
        }

        // Draw neural network visualization
        function drawNeuralNetwork(canvasId, creature) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !creature) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const network = creature.brain;
            const inputs = CONFIG.INPUT_NODES;
            const hidden = network.hiddenNodeCount; // Use actual hidden node count
            const outputs = CONFIG.OUTPUT_NODES;
            
            // Node positions (dynamic based on actual node count)
            const inputY = Array.from({length: inputs}, (_, i) => 20 + i * 10);
            const hiddenY = Array.from({length: hidden}, (_, i) => 20 + i * (120 / hidden)); // Scale spacing
            const outputY = Array.from({length: outputs}, (_, i) => 35 + i * 20);
            
            // Draw connections
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 0.5;
            
            // Input to hidden connections
            for (let i = 0; i < inputs; i++) {
                for (let h = 0; h < hidden; h++) {
                    const weight = network.inputToHidden[i][h];
                    ctx.strokeStyle = weight > 0 ? '#00ff00' : '#ff0000';
                    ctx.lineWidth = Math.abs(weight) * 2;
                    ctx.globalAlpha = 0.6;
                    
                    ctx.beginPath();
                    ctx.moveTo(30, inputY[i]);
                    ctx.lineTo(160, hiddenY[h]);
                    ctx.stroke();
                }
            }
            
            // Hidden to output connections
            for (let h = 0; h < hidden; h++) {
                for (let o = 0; o < outputs; o++) {
                    const weight = network.hiddenToOutput[h][o];
                    ctx.strokeStyle = weight > 0 ? '#00ff00' : '#ff0000';
                    ctx.lineWidth = Math.abs(weight) * 2;
                    ctx.globalAlpha = 0.6;
                    
                    ctx.beginPath();
                    ctx.moveTo(160, hiddenY[h]);
                    ctx.lineTo(290, outputY[o]);
                    ctx.stroke();
                }
            }
            
            ctx.globalAlpha = 1.0;
            
            // Draw nodes
            ctx.fillStyle = '#333';
            
            // Input nodes
            inputY.forEach(y => {
                ctx.beginPath();
                ctx.arc(30, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Hidden nodes (color varies by node count)
            ctx.fillStyle = hidden <= CONFIG.HIDDEN_NODES ? '#666' : '#ff9900'; // Orange for extra nodes
            hiddenY.forEach(y => {
                ctx.beginPath();
                ctx.arc(160, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Output nodes
            ctx.fillStyle = creature.type === 'HUNTER' ? '#ff6666' : '#6666ff';
            outputY.forEach(y => {
                ctx.beginPath();
                ctx.arc(290, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Add text label for hidden node count
            ctx.fillStyle = '#fff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${hidden} nodes`, 160, 150);
        }

        // ===== START THE SIMULATION =====
        // Wait for the page to load, then initialize
        window.addEventListener('load', init);

        /* ===============================
         * HOW TO CUSTOMIZE THIS SIMULATION:
         * 
         * 1. Modify CONFIG object at the top to change basic parameters
         * 2. Adjust creature types and behaviors in the Creature class
         * 3. Change fitness functions in calculateFitness() method
         * 4. Modify neural network structure in NeuralNetwork class
         * 5. Add new input types in getInputs() method
         * 6. Create new game modes by modifying the gameMode switch statements
         * 7. Adjust evolution parameters in the genetic algorithm functions
         * 
         * LATEST FEATURES ADDED:
         * - Cooperative tag removal: Same-type creatures can heal each other's tags
         * - Special abilities system: Unique mutations for hunters vs prey
         * - Enhanced strategic depth: Wall-baiting, teamwork, evasion tactics
         * 
         * HUNTER SPECIAL ABILITIES:
         * - Pack Hunting: Enhanced detection of prey
         * - Energy Vampire: Drain more energy when tagging
         * - Wall Bounce: Bounce off walls without damage
         * - Speed Burst: Temporary speed boost when low energy
         * - Territorial Instinct: Gain energy near other hunters
         * 
         * PREY SPECIAL ABILITIES:
         * - Camouflage: Become invisible to hunters periodically
         * - Evasion: Chance to avoid being tagged
         * - Energy Efficiency: Use less energy when moving
         * - Wall Phasing: Pass through walls (limited uses)
         * - Group Healing: Enhanced healing of nearby prey
         * 
         * STRATEGIC GAMEPLAY:
         * - Hunters can work together to corner prey
         * - Prey can lead hunters into walls for damage
         * - Same-type cooperation removes tags and provides healing
         * - Special abilities create unique creature lineages
         * - Energy management becomes crucial for survival
         * 
         * EXPERIMENT IDEAS:
         * - Create pack-hunting strategies by adjusting hunter abilities
         * - Test prey survival techniques with different ability combinations
         * - Adjust wall density to create maze-like tactical environments
         * - Modify ability mutation rates to see rapid evolution
         * - Create tournaments between different ability combinations
         * - Add environmental changes that favor different strategies
         * - Implement predator-prey population dynamics
         * - Create specialized roles within hunter/prey groups
         * =============================== */
    </script>
</body>
</html>