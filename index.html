<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolving NEAT Neural Network Ecosystem</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .grid-container {
            flex: 1;
            position: relative;
        }
        
        canvas {
            display: block;
            border: 1px solid #333;
        }
        
        .info-panel {
            width: 250px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-left: 1px solid #333;
            overflow-y: auto;
        }
        
        .stats {
            margin-bottom: 20px;
        }
        
        .stat-item {
            margin: 5px 0;
            font-size: 12px;
        }
        
        .creature-info {
            border: 1px solid #333;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .mutation-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin: 2px;
        }
        
        .title {
            text-align: center;
            margin-bottom: 20px;
            color: #00ffff;
        }
        
        .legend {
            font-size: 10px;
            margin-top: 20px;
        }
        
        .controls {
            margin-top: 20px;
        }
        
        button {
            background: #1a1a1a;
            color: #00ff00;
            border: 1px solid #333;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            font-family: inherit;
        }
        
        button:hover {
            background: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="grid-container">
            <canvas id="ecosystem"></canvas>
        </div>
        <div class="info-panel">
            <div class="title">NEAT Evolution Monitor</div>
            <div class="stats">
                <div class="stat-item">Population: <span id="population">0</span></div>
                <div class="stat-item">Evolution Time: <span id="time">0</span>s</div>
                <div class="stat-item">Total Tags: <span id="tags">0</span></div>
                <div class="stat-item">Avg Fitness: <span id="avgFitness">0</span></div>
                <div class="stat-item">Max Neural Nodes: <span id="maxNodes">0</span></div>
                <div class="stat-item">Mutations/sec: <span id="mutationRate">0</span></div>
            </div>
            
            <div class="controls">
                <button onclick="togglePause()">Pause/Resume</button>
                <button onclick="addRandomCreature()">Add Creature</button>
                <button onclick="increaseMutationRate()">Boost Mutations</button>
                <button onclick="resetEcosystem()">Reset</button>
            </div>
            
            <div class="legend">
                <h4>Creature Types:</h4>
                <div>ÔøΩ Hunter (Red tones) - Chases prey</div>
                <div>‚ö™ Prey (Blue tones) - Flees from hunters</div>
                <div>‚û§ Direction arrow shows movement</div>
                
                <h4>Role Switching:</h4>
                <div>When hunter tags prey:</div>
                <div>‚Ä¢ Hunter becomes prey</div>
                <div>‚Ä¢ Prey becomes hunter</div>
                
                <h4>Special Mutations:</h4>
                <div>‚ú® Speed Boost</div>
                <div>üõ°Ô∏è Armor Plating</div>
                <div>üëÅÔ∏è Enhanced Vision</div>
                <div>üß† Extra Neural Nodes</div>
                <div>‚ö° Energy Efficiency</div>
                <div>üéØ Precision Targeting</div>
                
                <h4>Pure NEAT Evolution:</h4>
                <div>‚Ä¢ No pre-programmed behaviors</div>
                <div>‚Ä¢ All movement from neural networks</div>
                <div>‚Ä¢ Networks evolve topology & weights</div>
                <div>‚Ä¢ Emergent strategies only</div>
            </div>
            
            <div id="selectedCreature" class="creature-info" style="display: none;">
                <h4>Selected Creature</h4>
                <div id="creatureDetails"></div>
            </div>
        </div>
    </div>

    <script>
        class NeuralNetwork {
            constructor(inputSize = 12, hiddenSizes = [], outputSize = 3) {
                this.inputSize = inputSize;
                this.hiddenSizes = hiddenSizes.length > 0 ? hiddenSizes : [Math.floor(Math.random() * 8) + 4];
                this.outputSize = outputSize;
                this.weights = [];
                this.biases = [];
                this.nodes = inputSize + this.hiddenSizes.reduce((a, b) => a + b, 0) + outputSize;
                this.connections = [];
                this.innovationNumber = 0;
                
                // NEAT-specific properties
                this.nodeGenes = [];
                this.connectionGenes = [];
                
                this.initializeNetwork();
            }
            
            initializeNetwork() {
                // Initialize with minimal topology - start simple and let NEAT add complexity
                const layers = [this.inputSize, ...this.hiddenSizes, this.outputSize];
                
                // Create node genes
                let nodeId = 0;
                for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
                    for (let nodeIndex = 0; nodeIndex < layers[layerIndex]; nodeIndex++) {
                        this.nodeGenes.push({
                            id: nodeId++,
                            type: layerIndex === 0 ? 'input' : layerIndex === layers.length - 1 ? 'output' : 'hidden',
                            layer: layerIndex,
                            bias: layerIndex > 0 ? (Math.random() * 2 - 1) : 0
                        });
                    }
                }
                
                // Create initial connection genes (minimal connections)
                for (let i = 0; i < layers.length - 1; i++) {
                    const currentLayerStart = layers.slice(0, i).reduce((a, b) => a + b, 0);
                    const nextLayerStart = layers.slice(0, i + 1).reduce((a, b) => a + b, 0);
                    
                    for (let from = currentLayerStart; from < currentLayerStart + layers[i]; from++) {
                        for (let to = nextLayerStart; to < nextLayerStart + layers[i + 1]; to++) {
                            // Only create some connections initially to allow NEAT to add more
                            if (Math.random() < 0.7) {
                                this.connectionGenes.push({
                                    innovation: this.innovationNumber++,
                                    from: from,
                                    to: to,
                                    weight: Math.random() * 2 - 1,
                                    enabled: true
                                });
                            }
                        }
                    }
                }
                
                this.compileNetwork();
            }
            
            compileNetwork() {
                // Convert genes to usable network structure
                const layers = [this.inputSize, ...this.hiddenSizes, this.outputSize];
                this.weights = [];
                this.biases = [];
                
                for (let i = 0; i < layers.length - 1; i++) {
                    const weightMatrix = [];
                    const biasVector = [];
                    
                    for (let j = 0; j < layers[i + 1]; j++) {
                        const weights = new Array(layers[i]).fill(0);
                        weightMatrix.push(weights);
                        biasVector.push(0);
                    }
                    
                    this.weights.push(weightMatrix);
                    this.biases.push(biasVector);
                }
                
                // Apply connection genes to weight matrix
                for (const connection of this.connectionGenes) {
                    if (!connection.enabled) continue;
                    
                    const fromNode = this.nodeGenes[connection.from];
                    const toNode = this.nodeGenes[connection.to];
                    
                    if (fromNode && toNode && toNode.layer > fromNode.layer) {
                        const layerIndex = toNode.layer - 1;
                        const fromIndex = connection.from - this.getLayerStartIndex(fromNode.layer);
                        const toIndex = connection.to - this.getLayerStartIndex(toNode.layer);
                        
                        if (this.weights[layerIndex] && this.weights[layerIndex][toIndex]) {
                            this.weights[layerIndex][toIndex][fromIndex] = connection.weight;
                        }
                    }
                }
                
                // Apply node biases
                for (let i = 1; i < this.nodeGenes.length; i++) {
                    const node = this.nodeGenes[i];
                    if (node.type !== 'input') {
                        const layerIndex = node.layer - 1;
                        const nodeIndex = i - this.getLayerStartIndex(node.layer);
                        if (this.biases[layerIndex]) {
                            this.biases[layerIndex][nodeIndex] = node.bias;
                        }
                    }
                }
            }
            
            getLayerStartIndex(layer) {
                const layers = [this.inputSize, ...this.hiddenSizes, this.outputSize];
                return layers.slice(0, layer).reduce((a, b) => a + b, 0);
            }
            
            forward(inputs) {
                let activations = inputs;
                
                for (let i = 0; i < this.weights.length; i++) {
                    const newActivations = [];
                    
                    for (let j = 0; j < this.weights[i].length; j++) {
                        let sum = this.biases[i][j];
                        for (let k = 0; k < activations.length; k++) {
                            sum += activations[k] * this.weights[i][j][k];
                        }
                        newActivations.push(this.tanh(sum));
                    }
                    
                    activations = newActivations;
                }
                
                return activations;
            }
            
            tanh(x) {
                return Math.tanh(x);
            }
            
            mutate(mutationRate = 0.1) {
                let mutationCount = 0;
                
                // Weight mutations
                for (const connection of this.connectionGenes) {
                    if (Math.random() < mutationRate) {
                        if (Math.random() < 0.9) {
                            // Perturb weight
                            connection.weight += (Math.random() - 0.5) * 0.5;
                        } else {
                            // Replace weight
                            connection.weight = Math.random() * 2 - 1;
                        }
                        mutationCount++;
                    }
                }
                
                // Bias mutations
                for (const node of this.nodeGenes) {
                    if (node.type !== 'input' && Math.random() < mutationRate) {
                        node.bias += (Math.random() - 0.5) * 0.5;
                        mutationCount++;
                    }
                }
                
                // Structural mutations - true NEAT
                if (Math.random() < mutationRate * 0.3) {
                    this.addConnectionMutation();
                    mutationCount += 3;
                }
                
                if (Math.random() < mutationRate * 0.1) {
                    this.addNodeMutation();
                    mutationCount += 5;
                }
                
                // Toggle connection
                if (Math.random() < mutationRate * 0.1) {
                    const randomConnection = this.connectionGenes[Math.floor(Math.random() * this.connectionGenes.length)];
                    if (randomConnection) {
                        randomConnection.enabled = !randomConnection.enabled;
                        mutationCount++;
                    }
                }
                
                this.compileNetwork();
                return mutationCount;
            }
            
            addConnectionMutation() {
                const maxAttempts = 20;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const fromNode = this.nodeGenes[Math.floor(Math.random() * this.nodeGenes.length)];
                    const toNode = this.nodeGenes[Math.floor(Math.random() * this.nodeGenes.length)];
                    
                    // Ensure forward connection and no self-loops
                    if (fromNode.layer < toNode.layer && fromNode.id !== toNode.id) {
                        // Check if connection already exists
                        const exists = this.connectionGenes.some(conn => 
                            conn.from === fromNode.id && conn.to === toNode.id
                        );
                        
                        if (!exists) {
                            this.connectionGenes.push({
                                innovation: this.innovationNumber++,
                                from: fromNode.id,
                                to: toNode.id,
                                weight: Math.random() * 2 - 1,
                                enabled: true
                            });
                            break;
                        }
                    }
                }
            }
            
            addNodeMutation() {
                if (this.connectionGenes.length === 0) return;
                
                // Split a random enabled connection
                const enabledConnections = this.connectionGenes.filter(conn => conn.enabled);
                if (enabledConnections.length === 0) return;
                
                const connectionToSplit = enabledConnections[Math.floor(Math.random() * enabledConnections.length)];
                connectionToSplit.enabled = false;
                
                // Add new hidden node
                const newNodeId = this.nodeGenes.length;
                const fromNode = this.nodeGenes[connectionToSplit.from];
                const toNode = this.nodeGenes[connectionToSplit.to];
                const newLayer = fromNode.layer + 1;
                
                // If we need to create a new layer
                if (newLayer >= toNode.layer) {
                    // Shift layers of subsequent nodes
                    for (const node of this.nodeGenes) {
                        if (node.layer >= newLayer && node.type === 'hidden') {
                            node.layer++;
                        }
                    }
                    this.hiddenSizes.push(1);
                } else {
                    // Find the appropriate hidden layer to add to
                    const layerIndex = newLayer - 1;
                    if (layerIndex < this.hiddenSizes.length) {
                        this.hiddenSizes[layerIndex]++;
                    }
                }
                
                this.nodeGenes.push({
                    id: newNodeId,
                    type: 'hidden',
                    layer: newLayer,
                    bias: Math.random() * 2 - 1
                });
                
                // Add connections: from original start to new node, and from new node to original end
                this.connectionGenes.push({
                    innovation: this.innovationNumber++,
                    from: connectionToSplit.from,
                    to: newNodeId,
                    weight: 1.0, // Maintain signal strength
                    enabled: true
                });
                
                this.connectionGenes.push({
                    innovation: this.innovationNumber++,
                    from: newNodeId,
                    to: connectionToSplit.to,
                    weight: connectionToSplit.weight,
                    enabled: true
                });
                
                this.nodes = this.nodeGenes.length;
            }
            
            copy() {
                const copy = new NeuralNetwork(this.inputSize, [...this.hiddenSizes], this.outputSize);
                
                // Deep copy node genes
                copy.nodeGenes = this.nodeGenes.map(node => ({...node}));
                
                // Deep copy connection genes
                copy.connectionGenes = this.connectionGenes.map(conn => ({...conn}));
                
                copy.innovationNumber = this.innovationNumber;
                copy.nodes = this.nodes;
                
                copy.compileNetwork();
                return copy;
            }
        }
        
        class Creature {
            constructor(x, y, ecosystem) {
                this.x = x;
                this.y = y;
                this.ecosystem = ecosystem;
                this.brain = new NeuralNetwork();
                
                this.energy = 100;
                this.fitness = 0;
                this.age = 0;
                this.tags = 0;
                this.speed = 1 + Math.random() * 0.5;
                this.vision = 50 + Math.random() * 30;
                this.size = 8 + Math.random() * 4;
                
                this.mutations = new Set();
                this.initializeMutations();
                
                this.color = this.generateColor();
                this.targetX = x;
                this.targetY = y;
                this.isHunter = Math.random() < 0.5; // Start with random roles
                this.tagCooldown = 0;
                this.lastTaggedBy = null;
                
                // Movement properties - PURE physics, no pre-baked behaviors
                this.velocityX = 0;
                this.velocityY = 0;
                this.maxVelocity = this.speed;
                
                // Remove personality system - let neural networks evolve all behavior
                this.id = Math.random().toString(36).substr(2, 9);
            }
            
            initializeMutations() {
                const possibleMutations = [
                    'speed_boost', 'armor_plating', 'enhanced_vision',
                    'extra_nodes', 'energy_efficiency', 'precision_targeting'
                ];
                
                const numMutations = Math.floor(Math.random() * 3);
                for (let i = 0; i < numMutations; i++) {
                    const mutation = possibleMutations[Math.floor(Math.random() * possibleMutations.length)];
                    this.mutations.add(mutation);
                }
                
                this.applyMutations();
            }
            
            applyMutations() {
                if (this.mutations.has('speed_boost')) {
                    this.speed *= 1.5;
                }
                if (this.mutations.has('armor_plating')) {
                    this.size *= 1.2;
                }
                if (this.mutations.has('enhanced_vision')) {
                    this.vision *= 1.5;
                }
                if (this.mutations.has('extra_nodes')) {
                    this.brain.hiddenSizes[0] += 2;
                    this.brain.initializeNetwork();
                }
                if (this.mutations.has('energy_efficiency')) {
                    this.energy *= 1.3;
                }
            }
            
            generateColor() {
                // Base color on role first, then mutations
                let baseColor;
                if (this.isHunter) {
                    baseColor = '#ff6666'; // Red for hunters
                } else {
                    baseColor = '#6666ff'; // Blue for prey
                }
                
                // Modify color based on mutations
                if (this.mutations.has('speed_boost')) return this.isHunter ? '#ff4444' : '#4444aa';
                if (this.mutations.has('armor_plating')) return this.isHunter ? '#aa4444' : '#444488';
                if (this.mutations.has('enhanced_vision')) return this.isHunter ? '#ff8844' : '#4488ff';
                if (this.mutations.has('extra_nodes')) return this.isHunter ? '#ffaaaa' : '#aaaaff';
                if (this.mutations.has('precision_targeting')) return this.isHunter ? '#ff44aa' : '#44aaff';
                if (this.mutations.has('energy_efficiency')) return this.isHunter ? '#ffaa44' : '#44aaff';
                
                return baseColor;
            }
            
            getInputs() {
                const inputs = [];
                const creatures = this.ecosystem.creatures;
                
                // Self state (normalized)
                inputs.push(this.energy / 100);
                inputs.push((this.x - this.ecosystem.canvas.width / 2) / (this.ecosystem.canvas.width / 2)); // Relative to center
                inputs.push((this.y - this.ecosystem.canvas.height / 2) / (this.ecosystem.canvas.height / 2));
                inputs.push(this.isHunter ? 1 : -1);
                inputs.push(this.velocityX / this.maxVelocity);
                inputs.push(this.velocityY / this.maxVelocity);
                
                // Find all nearby creatures and their relative positions
                const nearbyCreatures = [];
                for (const creature of creatures) {
                    if (creature === this) continue;
                    
                    const dx = creature.x - this.x;
                    const dy = creature.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.vision && distance > 0) {
                        nearbyCreatures.push({
                            creature,
                            dx: dx / this.vision,
                            dy: dy / this.vision,
                            distance: distance / this.vision,
                            isHunter: creature.isHunter
                        });
                    }
                }
                
                // Sort by distance and take closest 3 creatures
                nearbyCreatures.sort((a, b) => a.distance - b.distance);
                const closestCreatures = nearbyCreatures.slice(0, 3);
                
                // Add inputs for closest creatures (3 creatures * 2 inputs each = 6 inputs)
                for (let i = 0; i < 3; i++) {
                    if (i < closestCreatures.length) {
                        const creature = closestCreatures[i];
                        inputs.push(creature.dx);
                        inputs.push(creature.dy);
                        inputs.push(creature.distance);
                        inputs.push(creature.isHunter ? 1 : -1);
                    } else {
                        inputs.push(0, 0, 1, 0); // No creature detected
                    }
                }
                
                return inputs;
            }
            
            update() {
                this.age++;
                this.energy -= 0.1;
                
                if (this.tagCooldown > 0) {
                    this.tagCooldown--;
                }
                
                const inputs = this.getInputs();
                const outputs = this.brain.forward(inputs);
                
                // PURE neural network control - no pre-baked behaviors!
                // Neural network outputs: [velocityX, velocityY, attemptTag]
                
                // Apply neural network decisions directly
                const desiredVelX = outputs[0] * this.speed; // Range: -speed to +speed
                const desiredVelY = outputs[1] * this.speed;
                const shouldTag = outputs[2] > 0; // Sigmoid output > 0 means "attempt tag"
                
                // Smooth velocity changes (only physics, no behavior modification)
                this.velocityX += (desiredVelX - this.velocityX) * 0.3;
                this.velocityY += (desiredVelY - this.velocityY) * 0.3;
                
                // Limit velocity (physics constraint only)
                const velocity = Math.sqrt(this.velocityX * this.velocityX + this.velocityY * this.velocityY);
                if (velocity > this.maxVelocity) {
                    this.velocityX = (this.velocityX / velocity) * this.maxVelocity;
                    this.velocityY = (this.velocityY / velocity) * this.maxVelocity;
                }
                
                // Update position (pure physics)
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Boundary handling (physical constraints only)
                const buffer = this.size;
                if (this.x <= buffer || this.x >= this.ecosystem.canvas.width - buffer) {
                    this.velocityX *= -0.8; // Energy loss on collision
                    this.x = Math.max(buffer, Math.min(this.ecosystem.canvas.width - buffer, this.x));
                }
                if (this.y <= buffer || this.y >= this.ecosystem.canvas.height - buffer) {
                    this.velocityY *= -0.8;
                    this.y = Math.max(buffer, Math.min(this.ecosystem.canvas.height - buffer, this.y));
                }
                
                // Check for tagging - only based on neural network decision
                if (shouldTag && this.tagCooldown === 0) {
                    this.attemptTag();
                }
                
                // Fitness based purely on survival and success
                this.fitness += 0.1; // Base survival
                if (this.energy > 50) this.fitness += 0.1;
                
                // Energy cost for movement (realistic physics)
                const movementCost = velocity * 0.01;
                this.energy -= movementCost;
                
                return this.energy > 0;
            }
            
            attemptTag() {
                if (!this.isHunter) return; // Only hunters can tag (game rule, not AI bias)
                
                const creatures = this.ecosystem.creatures;
                
                for (const creature of creatures) {
                    if (creature === this || creature.isHunter) continue; // Can only tag prey
                    
                    const dx = creature.x - this.x;
                    const dy = creature.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.size + creature.size) {
                        // Successful tag! Switch roles
                        this.isHunter = false;
                        creature.isHunter = true;
                        
                        // Update colors
                        this.color = this.generateColor();
                        creature.color = creature.generateColor();
                        
                        // Update fitness and energy
                        this.tags++;
                        this.fitness += 20; // Reward for successful tag
                        this.energy += 30;
                        creature.fitness -= 5; // Small penalty for being caught
                        
                        this.tagCooldown = 60;
                        creature.tagCooldown = 30;
                        
                        this.ecosystem.totalTags++;
                        
                        break;
                    }
                }
            }
            
            reproduce() {
                const child = new Creature(
                    this.x + (Math.random() - 0.5) * 50,
                    this.y + (Math.random() - 0.5) * 50,
                    this.ecosystem
                );
                
                child.brain = this.brain.copy();
                const mutationCount = child.brain.mutate(0.2);
                this.ecosystem.totalMutations += mutationCount;
                
                // Inherit role and some properties
                child.isHunter = this.isHunter;
                
                // Inherit some mutations
                for (const mutation of this.mutations) {
                    if (Math.random() < 0.7) {
                        child.mutations.add(mutation);
                    }
                }
                
                // Possible new mutations
                const newMutations = [
                    'speed_boost', 'armor_plating', 'enhanced_vision',
                    'extra_nodes', 'energy_efficiency', 'precision_targeting'
                ];
                
                if (Math.random() < 0.3) {
                    const newMutation = newMutations[Math.floor(Math.random() * newMutations.length)];
                    child.mutations.add(newMutation);
                }
                
                child.applyMutations();
                child.color = child.generateColor();
                
                this.energy -= 30;
                
                return child;
            }
            
            draw(ctx) {
                // Ensure valid position and context
                if (!ctx || this.x == null || this.y == null || this.size == null) {
                    return;
                }
                
                // Main body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Role indicator
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                if (this.isHunter) {
                    // Triangle for hunters
                    ctx.moveTo(this.x, this.y - this.size * 0.5);
                    ctx.lineTo(this.x - this.size * 0.3, this.y + this.size * 0.3);
                    ctx.lineTo(this.x + this.size * 0.3, this.y + this.size * 0.3);
                    ctx.closePath();
                } else {
                    // Circle for prey
                    ctx.arc(this.x, this.y, this.size * 0.3, 0, Math.PI * 2);
                }
                ctx.fill();
                
                // Velocity indicator (direction arrow)
                const velocity = Math.sqrt(this.velocityX * this.velocityX + this.velocityY * this.velocityY);
                if (velocity > 0.1) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    const arrowLength = this.size * 1.5;
                    const endX = this.x + (this.velocityX / velocity) * arrowLength;
                    const endY = this.y + (this.velocityY / velocity) * arrowLength;
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                
                // Mutation indicators
                if (this.mutations) {
                    let indicatorIndex = 0;
                    for (const mutation of this.mutations) {
                        const angle = (indicatorIndex / this.mutations.size) * Math.PI * 2;
                        const indicatorX = this.x + Math.cos(angle) * (this.size + 5);
                        const indicatorY = this.y + Math.sin(angle) * (this.size + 5);
                        
                        ctx.fillStyle = this.getMutationColor(mutation);
                        ctx.beginPath();
                        ctx.arc(indicatorX, indicatorY, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        indicatorIndex++;
                    }
                }
                
                // Vision range (for selected creature)
                if (this.ecosystem.selectedCreature === this) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.vision, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            getMutationColor(mutation) {
                const colors = {
                    'speed_boost': '#ffff00',
                    'armor_plating': '#888888',
                    'enhanced_vision': '#00ffff',
                    'extra_nodes': '#ff00ff',
                    'energy_efficiency': '#00ff00',
                    'precision_targeting': '#ff8800'
                };
                return colors[mutation] || '#ffffff';
            }
        }
        
        class Ecosystem {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.creatures = [];
                this.selectedCreature = null;
                
                this.totalTags = 0;
                this.totalMutations = 0;
                this.startTime = Date.now();
                this.isPaused = false;
                
                this.baseMutationRate = 0.1;
                this.currentMutationRate = this.baseMutationRate;
                
                // Set up canvas properly
                this.setupCanvas();
                this.setupEventListeners();
                
                // Initialize population immediately
                this.initializePopulation();
            }
            
            setupCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth || 800;
                this.canvas.height = container.clientHeight || 600;
                
                // Add resize listener that properly handles resize
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
            }
            
            handleResize() {
                const container = this.canvas.parentElement;
                const newWidth = container.clientWidth || 800;
                const newHeight = container.clientHeight || 600;
                
                // Scale creature positions if canvas size changes
                const scaleX = newWidth / this.canvas.width;
                const scaleY = newHeight / this.canvas.height;
                
                this.canvas.width = newWidth;
                this.canvas.height = newHeight;
                
                // Scale all creature positions
                for (const creature of this.creatures) {
                    creature.x *= scaleX;
                    creature.y *= scaleY;
                    
                    // Ensure creatures stay within bounds
                    creature.x = Math.max(creature.size, Math.min(this.canvas.width - creature.size, creature.x));
                    creature.y = Math.max(creature.size, Math.min(this.canvas.height - creature.size, creature.y));
                }
            }
            
            initializePopulation() {
                // Clear existing creatures
                this.creatures = [];
                
                const initialPopulation = 50;
                
                // Ensure we have valid canvas dimensions
                const width = this.canvas.width || 800;
                const height = this.canvas.height || 600;
                
                for (let i = 0; i < initialPopulation; i++) {
                    const x = Math.random() * (width - 60) + 30; // 30px buffer from edges
                    const y = Math.random() * (height - 60) + 30;
                    const creature = new Creature(x, y, this);
                    this.creatures.push(creature);
                }
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;
                    
                    let clickedCreature = null;
                    let minDistance = Infinity;
                    
                    for (const creature of this.creatures) {
                        const dx = creature.x - clickX;
                        const dy = creature.y - clickY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < creature.size && distance < minDistance) {
                            minDistance = distance;
                            clickedCreature = creature;
                        }
                    }
                    
                    this.selectedCreature = clickedCreature;
                    this.updateCreatureInfo();
                });
            }
            
            update() {
                if (this.isPaused) return;
                
                // Update all creatures
                this.creatures = this.creatures.filter(creature => creature.update());
                
                // Continuous evolution - reproduce high fitness creatures
                const sortedCreatures = [...this.creatures].sort((a, b) => b.fitness - a.fitness);
                
                // Reproduce top performers
                if (this.creatures.length < 200) {
                    const reproductionThreshold = Math.max(50, this.creatures.length * 0.3);
                    
                    for (let i = 0; i < Math.min(5, sortedCreatures.length); i++) {
                        const parent = sortedCreatures[i];
                        if (parent.fitness > reproductionThreshold && parent.energy > 50) {
                            const child = parent.reproduce();
                            this.creatures.push(child);
                        }
                    }
                }
                
                // Remove low fitness creatures periodically
                if (this.creatures.length > 150) {
                    const removeCount = Math.floor(this.creatures.length * 0.1);
                    const toRemove = sortedCreatures.slice(-removeCount);
                    
                    for (const creature of toRemove) {
                        const index = this.creatures.indexOf(creature);
                        if (index > -1) {
                            this.creatures.splice(index, 1);
                        }
                    }
                }
                
                // Balance hunter/prey ratio
                const hunters = this.creatures.filter(c => c.isHunter);
                const prey = this.creatures.filter(c => !c.isHunter);
                
                // If too many hunters, convert some to prey
                if (hunters.length > prey.length * 2) {
                    const excessHunters = hunters.slice(0, Math.floor(hunters.length * 0.2));
                    for (const hunter of excessHunters) {
                        hunter.isHunter = false;
                        hunter.color = hunter.generateColor();
                    }
                }
                
                // If too many prey, convert some to hunters
                if (prey.length > hunters.length * 3) {
                    const excessPrey = prey.slice(0, Math.floor(prey.length * 0.1));
                    for (const preyCreature of excessPrey) {
                        preyCreature.isHunter = true;
                        preyCreature.color = preyCreature.generateColor();
                    }
                }
                
                // Add random mutations to environment
                if (Math.random() < this.currentMutationRate * 0.1) {
                    const randomCreature = this.creatures[Math.floor(Math.random() * this.creatures.length)];
                    if (randomCreature) {
                        this.totalMutations += randomCreature.brain.mutate(this.currentMutationRate);
                    }
                }
                
                // Decay mutation rate back to base
                this.currentMutationRate = Math.max(this.baseMutationRate, this.currentMutationRate * 0.999);
            }
            
            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                // Draw creatures
                if (this.creatures && this.creatures.length > 0) {
                    for (const creature of this.creatures) {
                        if (creature && creature.draw) {
                            creature.draw(this.ctx);
                        }
                    }
                }
                
                this.updateStats();
            }
            
            updateStats() {
                const currentTime = Date.now();
                const elapsedTime = Math.floor((currentTime - this.startTime) / 1000);
                
                const hunters = this.creatures.filter(c => c.isHunter);
                const prey = this.creatures.filter(c => !c.isHunter);
                
                document.getElementById('population').textContent = `${this.creatures.length} (H:${hunters.length} P:${prey.length})`;
                document.getElementById('time').textContent = elapsedTime;
                document.getElementById('tags').textContent = this.totalTags;
                
                const avgFitness = this.creatures.length > 0 
                    ? (this.creatures.reduce((sum, c) => sum + c.fitness, 0) / this.creatures.length).toFixed(1)
                    : 0;
                document.getElementById('avgFitness').textContent = avgFitness;
                
                const maxNodes = Math.max(...this.creatures.map(c => c.brain.nodes));
                document.getElementById('maxNodes').textContent = maxNodes;
                
                const mutationRate = (this.totalMutations / Math.max(1, elapsedTime)).toFixed(2);
                document.getElementById('mutationRate').textContent = mutationRate;
            }
            
            updateCreatureInfo() {
                const infoPanel = document.getElementById('selectedCreature');
                const detailsDiv = document.getElementById('creatureDetails');
                
                if (this.selectedCreature) {
                    infoPanel.style.display = 'block';
                    
                    const creature = this.selectedCreature;
                    const mutationList = Array.from(creature.mutations).join(', ') || 'None';
                    
                    detailsDiv.innerHTML = `
                        <div>ID: ${creature.id}</div>
                        <div>Role: ${creature.isHunter ? 'Hunter üî∫' : 'Prey ‚ö™'}</div>
                        <div>Age: ${creature.age}</div>
                        <div>Energy: ${creature.energy.toFixed(1)}</div>
                        <div>Fitness: ${creature.fitness.toFixed(1)}</div>
                        <div>Tags: ${creature.tags}</div>
                        <div>Speed: ${creature.speed.toFixed(2)}</div>
                        <div>Vision: ${creature.vision.toFixed(0)}</div>
                        <div>Neural Nodes: ${creature.brain.nodes}</div>
                        <div>Connections: ${creature.brain.connectionGenes.filter(c => c.enabled).length}</div>
                        <div>Mutations: ${mutationList}</div>
                        <div>Velocity: ${Math.sqrt(creature.velocityX * creature.velocityX + creature.velocityY * creature.velocityY).toFixed(2)}</div>
                    `;
                } else {
                    infoPanel.style.display = 'none';
                }
            }
            
            addRandomCreature() {
                const width = this.canvas.width || 800;
                const height = this.canvas.height || 600;
                const x = Math.random() * (width - 60) + 30;
                const y = Math.random() * (height - 60) + 30;
                this.creatures.push(new Creature(x, y, this));
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
            }
            
            increaseMutationRate() {
                this.currentMutationRate = Math.min(1.0, this.currentMutationRate * 2);
            }
            
            reset() {
                this.creatures = [];
                this.selectedCreature = null;
                this.totalTags = 0;
                this.totalMutations = 0;
                this.startTime = Date.now();
                this.currentMutationRate = this.baseMutationRate;
                this.initializePopulation();
            }
        }
        
        // Global functions for controls
        let ecosystem;
        
        function togglePause() {
            ecosystem.togglePause();
        }
        
        function addRandomCreature() {
            ecosystem.addRandomCreature();
        }
        
        function increaseMutationRate() {
            ecosystem.increaseMutationRate();
        }
        
        function resetEcosystem() {
            ecosystem.reset();
        }
        
        // Initialize the ecosystem
        window.addEventListener('load', () => {
            // Wait for DOM to be fully ready
            setTimeout(() => {
                ecosystem = new Ecosystem('ecosystem');
                
                function gameLoop() {
                    if (ecosystem && ecosystem.creatures) {
                        ecosystem.update();
                        ecosystem.draw();
                    }
                    requestAnimationFrame(gameLoop);
                }
                
                gameLoop();
            }, 200);
        });
    </script>
</body>
</html>