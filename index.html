<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Continuous Evolution NEAT Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            background: #1a1a1a;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            // Visual settings
            CANVAS_WIDTH: window.innerWidth,
            CANVAS_HEIGHT: window.innerHeight,
            GRID_SIZE: 30,
            
            // Neural network parameters
            INPUT_NODES: 8,             // 8-direction vision
            OUTPUT_NODES: 4,            // UP, DOWN, LEFT, RIGHT
            MIN_HIDDEN_NODES: 3,
            MAX_HIDDEN_NODES: 10,
            
            // Population settings
            MAX_HUNTERS: 15,
            MAX_PREY: 15,
            RESPAWN_DELAY: 60,          // Frames before respawn
            
            // Energy system
            STARTING_ENERGY: 80,
            MAX_ENERGY: 120,
            ENERGY_DECAY: 0.15,
            ENERGY_MOVE_COST: 0.3,
            ENERGY_DEATH_THRESHOLD: 0.1,
            
            // Combat system
            TAG_DISTANCE: 1,
            MAX_TAGS_BEFORE_OUT: 2,
            ENERGY_GAIN_TAG: 15,
            ENERGY_GAIN_SURVIVAL: 0.1,
            
            // Evolution parameters
            MUTATION_RATE: 0.3,
            NODE_ADD_RATE: 0.06,
            NODE_REMOVE_RATE: 0.03,
            ELITE_THRESHOLD: 0.7,       // Top 70% for breeding
            ABILITY_MUTATION_RATE: 0.08,
            MAX_SPECIAL_ABILITIES: 2,
            
            // Environment
            WALL_DENSITY: 0.03,
            WALL_KILL_ENERGY: 30,
            VISION_RANGE: 3,
            
            // Speed control
            MIN_SIMULATION_SPEED: 0.1,
            MAX_SIMULATION_SPEED: 10.0,
            DEFAULT_SIMULATION_SPEED: 1.0,
            
            // Fitness rewards
            HUNTER_TAG_REWARD: 100,
            HUNTER_SURVIVAL_REWARD: 0.5,
            PREY_SURVIVAL_REWARD: 1.0,
            PREY_EVASION_REWARD: 50,
            
            // Colors
            COLORS: {
                HUNTER: '#ff4444',
                PREY: '#4444ff',
                WALL: '#9966cc'
            }
        };

        // ===== GLOBAL VARIABLES =====
        let canvas, ctx;
        let creatures = [];
        let walls = [];
        let frameCount = 0;
        let isPaused = false;
        let simulationSpeed = CONFIG.DEFAULT_SIMULATION_SPEED;
        
        // Continuous evolution tracking
        let respawnQueue = [];
        let fitnessHistory = { hunters: [], prey: [] };
        let totalCreaturesSpawned = 0;
        
        let stats = {
            huntersAlive: 0,
            preyAlive: 0,
            totalTags: 0,
            totalRespawns: 0,
            avgHunterFitness: 0,
            avgPreyFitness: 0,
            bestHunterFitness: 0,
            bestPreyFitness: 0
        };

        // ===== NEURAL NETWORK CLASS =====
        class NeuralNetwork {
            constructor(hiddenNodeCount = null) {
                this.hiddenNodeCount = hiddenNodeCount || 
                    (CONFIG.MIN_HIDDEN_NODES + Math.floor(Math.random() * (CONFIG.MAX_HIDDEN_NODES - CONFIG.MIN_HIDDEN_NODES + 1)));
                
                // Initialize matrices
                this.inputToHidden = this.createMatrix(CONFIG.INPUT_NODES, this.hiddenNodeCount);
                this.hiddenToOutput = this.createMatrix(this.hiddenNodeCount, CONFIG.OUTPUT_NODES);
                this.hiddenBias = this.createArray(this.hiddenNodeCount);
                this.outputBias = this.createArray(CONFIG.OUTPUT_NODES);
                
                this.randomize();
                this.complexity = this.calculateComplexity();
            }

            createMatrix(rows, cols) {
                return Array(rows).fill().map(() => Array(cols).fill(0));
            }

            createArray(size) {
                return Array(size).fill(0);
            }

            randomize() {
                // Random weights between -1 and 1
                for (let i = 0; i < CONFIG.INPUT_NODES; i++) {
                    for (let j = 0; j < this.hiddenNodeCount; j++) {
                        this.inputToHidden[i][j] = (Math.random() * 2) - 1;
                    }
                }
                
                for (let i = 0; i < this.hiddenNodeCount; i++) {
                    for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                        this.hiddenToOutput[i][j] = (Math.random() * 2) - 1;
                    }
                }
                
                for (let i = 0; i < this.hiddenNodeCount; i++) {
                    this.hiddenBias[i] = (Math.random() * 2) - 1;
                }
                
                for (let i = 0; i < CONFIG.OUTPUT_NODES; i++) {
                    this.outputBias[i] = (Math.random() * 2) - 1;
                }
            }

            feedForward(inputs) {
                // Calculate hidden layer
                let hidden = Array(this.hiddenNodeCount).fill(0);
                for (let i = 0; i < this.hiddenNodeCount; i++) {
                    for (let j = 0; j < CONFIG.INPUT_NODES; j++) {
                        hidden[i] += inputs[j] * this.inputToHidden[j][i];
                    }
                    hidden[i] += this.hiddenBias[i];
                    hidden[i] = this.activate(hidden[i]);
                }
                
                // Calculate output layer
                let outputs = Array(CONFIG.OUTPUT_NODES).fill(0);
                for (let i = 0; i < CONFIG.OUTPUT_NODES; i++) {
                    for (let j = 0; j < this.hiddenNodeCount; j++) {
                        outputs[i] += hidden[j] * this.hiddenToOutput[j][i];
                    }
                    outputs[i] += this.outputBias[i];
                    outputs[i] = this.activate(outputs[i]);
                }
                
                return outputs;
            }

            activate(x) {
                return 1 / (1 + Math.exp(-x)); // Sigmoid activation
            }

            calculateComplexity() {
                return (CONFIG.INPUT_NODES * this.hiddenNodeCount) + 
                       (this.hiddenNodeCount * CONFIG.OUTPUT_NODES) + 
                       this.hiddenNodeCount + CONFIG.OUTPUT_NODES;
            }

            copy() {
                let newNetwork = new NeuralNetwork(this.hiddenNodeCount);
                
                // Copy all weights and biases
                for (let i = 0; i < CONFIG.INPUT_NODES; i++) {
                    for (let j = 0; j < this.hiddenNodeCount; j++) {
                        newNetwork.inputToHidden[i][j] = this.inputToHidden[i][j];
                    }
                }
                
                for (let i = 0; i < this.hiddenNodeCount; i++) {
                    for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                        newNetwork.hiddenToOutput[i][j] = this.hiddenToOutput[i][j];
                    }
                }
                
                for (let i = 0; i < this.hiddenNodeCount; i++) {
                    newNetwork.hiddenBias[i] = this.hiddenBias[i];
                }
                
                for (let i = 0; i < CONFIG.OUTPUT_NODES; i++) {
                    newNetwork.outputBias[i] = this.outputBias[i];
                }
                
                newNetwork.complexity = this.complexity;
                return newNetwork;
            }

            mutate(rate) {
                // Mutate all weights and biases
                for (let i = 0; i < CONFIG.INPUT_NODES; i++) {
                    for (let j = 0; j < this.hiddenNodeCount; j++) {
                        if (Math.random() < rate) {
                            this.inputToHidden[i][j] += (Math.random() * 0.4) - 0.2;
                            this.inputToHidden[i][j] = Math.max(-1, Math.min(1, this.inputToHidden[i][j]));
                        }
                    }
                }
                
                for (let i = 0; i < this.hiddenNodeCount; i++) {
                    for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                        if (Math.random() < rate) {
                            this.hiddenToOutput[i][j] += (Math.random() * 0.4) - 0.2;
                            this.hiddenToOutput[i][j] = Math.max(-1, Math.min(1, this.hiddenToOutput[i][j]));
                        }
                    }
                }
                
                for (let i = 0; i < this.hiddenNodeCount; i++) {
                    if (Math.random() < rate) {
                        this.hiddenBias[i] += (Math.random() * 0.4) - 0.2;
                        this.hiddenBias[i] = Math.max(-1, Math.min(1, this.hiddenBias[i]));
                    }
                }
                
                for (let i = 0; i < CONFIG.OUTPUT_NODES; i++) {
                    if (Math.random() < rate) {
                        this.outputBias[i] += (Math.random() * 0.4) - 0.2;
                        this.outputBias[i] = Math.max(-1, Math.min(1, this.outputBias[i]));
                    }
                }
            }

            mutateTopology() {
                // Add node
                if (Math.random() < CONFIG.NODE_ADD_RATE && this.hiddenNodeCount < CONFIG.MAX_HIDDEN_NODES) {
                    this.addHiddenNode();
                }
                
                // Remove node
                if (Math.random() < CONFIG.NODE_REMOVE_RATE && this.hiddenNodeCount > CONFIG.MIN_HIDDEN_NODES) {
                    this.removeHiddenNode();
                }
            }

            addHiddenNode() {
                let oldHiddenCount = this.hiddenNodeCount;
                this.hiddenNodeCount++;
                
                // Expand matrices
                let newInputToHidden = this.createMatrix(CONFIG.INPUT_NODES, this.hiddenNodeCount);
                let newHiddenToOutput = this.createMatrix(this.hiddenNodeCount, CONFIG.OUTPUT_NODES);
                let newHiddenBias = this.createArray(this.hiddenNodeCount);
                
                // Copy old weights
                for (let i = 0; i < CONFIG.INPUT_NODES; i++) {
                    for (let j = 0; j < oldHiddenCount; j++) {
                        newInputToHidden[i][j] = this.inputToHidden[i][j];
                    }
                    newInputToHidden[i][oldHiddenCount] = (Math.random() * 2) - 1; // New node
                }
                
                for (let i = 0; i < oldHiddenCount; i++) {
                    for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                        newHiddenToOutput[i][j] = this.hiddenToOutput[i][j];
                    }
                }
                
                for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                    newHiddenToOutput[oldHiddenCount][j] = (Math.random() * 2) - 1; // New node
                }
                
                for (let i = 0; i < oldHiddenCount; i++) {
                    newHiddenBias[i] = this.hiddenBias[i];
                }
                newHiddenBias[oldHiddenCount] = (Math.random() * 2) - 1; // New node
                
                this.inputToHidden = newInputToHidden;
                this.hiddenToOutput = newHiddenToOutput;
                this.hiddenBias = newHiddenBias;
                this.complexity = this.calculateComplexity();
            }

            removeHiddenNode() {
                if (this.hiddenNodeCount <= CONFIG.MIN_HIDDEN_NODES) return;
                
                let oldHiddenCount = this.hiddenNodeCount;
                this.hiddenNodeCount--;
                
                let nodeToRemove = Math.floor(Math.random() * oldHiddenCount);
                
                // Create smaller matrices
                let newInputToHidden = this.createMatrix(CONFIG.INPUT_NODES, this.hiddenNodeCount);
                let newHiddenToOutput = this.createMatrix(this.hiddenNodeCount, CONFIG.OUTPUT_NODES);
                let newHiddenBias = this.createArray(this.hiddenNodeCount);
                
                // Copy weights, skipping removed node
                for (let i = 0; i < CONFIG.INPUT_NODES; i++) {
                    let newJ = 0;
                    for (let j = 0; j < oldHiddenCount; j++) {
                        if (j !== nodeToRemove) {
                            newInputToHidden[i][newJ] = this.inputToHidden[i][j];
                            newJ++;
                        }
                    }
                }
                
                let newI = 0;
                for (let i = 0; i < oldHiddenCount; i++) {
                    if (i !== nodeToRemove) {
                        for (let j = 0; j < CONFIG.OUTPUT_NODES; j++) {
                            newHiddenToOutput[newI][j] = this.hiddenToOutput[i][j];
                        }
                        newHiddenBias[newI] = this.hiddenBias[i];
                        newI++;
                    }
                }
                
                this.inputToHidden = newInputToHidden;
                this.hiddenToOutput = newHiddenToOutput;
                this.hiddenBias = newHiddenBias;
                this.complexity = this.calculateComplexity();
            }
        }

        // ===== WALL CLASS =====
        class Wall {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            draw() {
                let pixelX = this.x * CONFIG.GRID_SIZE;
                let pixelY = this.y * CONFIG.GRID_SIZE;
                
                ctx.fillStyle = CONFIG.COLORS.WALL;
                ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                
                // Danger outline
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(pixelX + 1, pixelY + 1, CONFIG.GRID_SIZE - 3, CONFIG.GRID_SIZE - 3);
            }
        }

        // ===== CREATURE CLASS =====
        class Creature {
            constructor(x, y, type, parentBrain = null) {
                this.x = x || Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE));
                this.y = y || Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE));
                this.type = type;
                this.id = totalCreaturesSpawned++;
                this.isAlive = true;
                
                // Brain - inherit or create new
                if (parentBrain) {
                    this.brain = parentBrain.copy();
                    this.brain.mutate(CONFIG.MUTATION_RATE);
                    this.brain.mutateTopology();
                } else {
                    this.brain = new NeuralNetwork();
                }
                
                // Stats
                this.fitness = 0;
                this.lifetimeFrames = 0;
                this.totalTags = 0;
                this.energy = CONFIG.STARTING_ENERGY;
                this.maxEnergyReached = CONFIG.STARTING_ENERGY;
                this.timesTagged = 0;
                this.tagCooldown = 0;
                this.framesSinceLastMove = 0;
                this.totalDistance = 0;
                
                // Simplified special abilities (only 6 core abilities)
                this.specialAbilities = {
                    // Hunter abilities
                    packHunting: false,     // Enhanced prey detection
                    energyVampire: false,   // Drain more energy when tagging
                    speedBurst: false,      // Temporary speed boost
                    
                    // Prey abilities
                    evasion: false,         // Chance to avoid tags
                    energyEfficiency: false,// Use less energy
                    camouflage: false,      // Harder to detect
                    
                    // Negative traits
                    lethargy: false,        // Move slower, use more energy
                    anxiety: false          // Avoid others
                };
                
                this.abilityUses = { speedBurst: 3 };
                this.abilityCooldowns = { speedBurst: 0, evasion: 0, camouflage: 0 };
                
                this.findSafeStartingPosition();
            }

            findSafeStartingPosition() {
                for (let attempts = 0; attempts < 100; attempts++) {
                    let testX = Math.floor(Math.random() * (CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE));
                    let testY = Math.floor(Math.random() * (CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE));
                    
                    if (this.isPositionSafe(testX, testY)) {
                        this.x = testX;
                        this.y = testY;
                        return;
                    }
                }
            }

            isPositionSafe(x, y) {
                // Check boundaries
                if (x < 0 || x >= CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE ||
                    y < 0 || y >= CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE) {
                    return false;
                }
                
                // Check walls
                for (let wall of walls) {
                    if (wall.x === x && wall.y === y) return false;
                }
                
                // Check other creatures
                for (let creature of creatures) {
                    if (creature !== this && creature.isAlive && 
                        creature.x === x && creature.y === y) {
                        return false;
                    }
                }
                
                return true;
            }

            getInputs() {
                let inputs = [];
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];

                for (let dir of directions) {
                    inputs.push(this.lookInDirection(dir[0], dir[1]));
                }

                return inputs;
            }

            lookInDirection(dirX, dirY) {
                for (let distance = 1; distance <= CONFIG.VISION_RANGE; distance++) {
                    let checkX = this.x + (dirX * distance);
                    let checkY = this.y + (dirY * distance);
                    
                    // Check bounds
                    if (checkX < 0 || checkX >= CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE ||
                        checkY < 0 || checkY >= CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE) {
                        return 0; // Boundary
                    }
                    
                    // Check walls
                    for (let wall of walls) {
                        if (wall.x === checkX && wall.y === checkY) {
                            return 0; // Wall
                        }
                    }
                    
                    // Check creatures
                    for (let creature of creatures) {
                        if (creature !== this && creature.isAlive && 
                            creature.x === checkX && creature.y === checkY) {
                            
                            // Pack hunting enhancement
                            if (this.specialAbilities.packHunting && 
                                this.type === 'HUNTER' && creature.type === 'PREY') {
                                return 0.9;
                            }
                            
                            // Camouflage effect
                            if (creature.specialAbilities.camouflage && 
                                creature.abilityCooldowns.camouflage > 0 && 
                                this.type === 'HUNTER') {
                                continue; // Invisible
                            }
                            
                            // Return relationship values
                            if (this.type === 'HUNTER' && creature.type === 'PREY') {
                                return 0.8; // Target
                            } else if (this.type === 'PREY' && creature.type === 'HUNTER') {
                                return 0.2; // Danger
                            } else {
                                return 0.6; // Same type
                            }
                        }
                    }
                }
                
                return 1; // Clear
            }

            think() {
                if (!this.isAlive) return;
                
                let inputs = this.getInputs();
                let outputs = this.brain.feedForward(inputs);
                
                let maxOutput = Math.max(...outputs);
                let chosenDirection = outputs.indexOf(maxOutput);
                
                // Lethargy effect
                if (this.specialAbilities.lethargy && Math.random() < 0.3) {
                    return;
                }
                
                // Anxiety effect - flee from others
                if (this.specialAbilities.anxiety) {
                    let nearby = creatures.filter(c => 
                        c !== this && c.isAlive &&
                        Math.abs(c.x - this.x) <= 2 && Math.abs(c.y - this.y) <= 2
                    );
                    
                    if (nearby.length > 0 && Math.random() < 0.6) {
                        let nearest = nearby[0];
                        chosenDirection = this.getDirectionAwayFrom(nearest.x, nearest.y);
                    }
                }
                
                this.move(chosenDirection);
            }

            getDirectionAwayFrom(targetX, targetY) {
                let dx = this.x - targetX;
                let dy = this.y - targetY;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    return dx > 0 ? 3 : 2; // RIGHT or LEFT
                } else {
                    return dy > 0 ? 1 : 0; // DOWN or UP
                }
            }

            move(direction) {
                if (!this.isAlive) return;
                
                let newX = this.x;
                let newY = this.y;
                let moveDistance = 1;
                
                // Speed burst ability
                if (this.specialAbilities.speedBurst && 
                    this.energy < CONFIG.STARTING_ENERGY * 0.3 && 
                    this.abilityUses.speedBurst > 0 &&
                    this.abilityCooldowns.speedBurst === 0) {
                    moveDistance = 2;
                    this.abilityUses.speedBurst--;
                    this.abilityCooldowns.speedBurst = 30;
                }
                
                // Calculate new position
                switch(direction) {
                    case 0: newY -= moveDistance; break; // UP
                    case 1: newY += moveDistance; break; // DOWN
                    case 2: newX -= moveDistance; break; // LEFT
                    case 3: newX += moveDistance; break; // RIGHT
                }
                
                // Try to move
                if (this.isPositionSafe(newX, newY)) {
                    let actuallyMoved = (this.x !== newX || this.y !== newY);
                    
                    this.x = newX;
                    this.y = newY;
                    
                    if (actuallyMoved) {
                        this.framesSinceLastMove = 0;
                        this.totalDistance += moveDistance;
                    } else {
                        this.framesSinceLastMove++;
                    }
                    
                    // Energy cost
                    let energyCost = CONFIG.ENERGY_MOVE_COST;
                    if (this.specialAbilities.energyEfficiency) {
                        energyCost *= 0.7;
                    }
                    if (this.specialAbilities.lethargy) {
                        energyCost *= 1.5;
                    }
                    
                    this.energy -= energyCost;
                } else {
                    this.framesSinceLastMove++;
                    this.handleWallCollision(newX, newY);
                }
                
                // Update state
                this.lifetimeFrames++;
                this.updateAbilityCooldowns();
                
                // Energy decay
                this.energy -= CONFIG.ENERGY_DECAY;
                if (this.energy < 5 && this.energy > 0) {
                    this.energy -= 0.1; // Extra drain for very low energy
                }
                
                // Survival bonus for prey
                if (this.type === 'PREY') {
                    this.energy += CONFIG.ENERGY_GAIN_SURVIVAL;
                }
                
                this.checkElimination();
            }

            handleWallCollision(attemptedX, attemptedY) {
                for (let wall of walls) {
                    if (wall.x === attemptedX && wall.y === attemptedY) {
                        this.energy -= CONFIG.WALL_KILL_ENERGY;
                        return;
                    }
                }
            }

            updateAbilityCooldowns() {
                Object.keys(this.abilityCooldowns).forEach(ability => {
                    if (this.abilityCooldowns[ability] > 0) {
                        this.abilityCooldowns[ability]--;
                    }
                });
                
                // Activate camouflage
                if (this.specialAbilities.camouflage && 
                    this.type === 'PREY' && 
                    this.abilityCooldowns.camouflage === 0 &&
                    Math.random() < 0.05) {
                    this.abilityCooldowns.camouflage = 60;
                }
            }

            checkElimination() {
                if (!this.isAlive) return;
                
                this.energy = Math.max(0, Math.min(CONFIG.MAX_ENERGY, this.energy));
                
                if (this.energy <= CONFIG.ENERGY_DEATH_THRESHOLD) {
                    this.eliminate('Energy Depleted');
                } else if (this.timesTagged >= CONFIG.MAX_TAGS_BEFORE_OUT) {
                    this.eliminate('Tagged Out');
                } else if (this.framesSinceLastMove > 500) {
                    this.eliminate('Chronic Inactivity');
                }
            }

            eliminate(reason) {
                this.isAlive = false;
                this.calculateFinalFitness();
                
                // Queue for respawn
                respawnQueue.push({
                    type: this.type,
                    brain: this.brain,
                    fitness: this.fitness,
                    respawnFrame: frameCount + CONFIG.RESPAWN_DELAY
                });
                
                // Update fitness history
                if (this.type === 'HUNTER') {
                    fitnessHistory.hunters.push({brain: this.brain.copy(), fitness: this.fitness});
                    if (fitnessHistory.hunters.length > 20) fitnessHistory.hunters.shift();
                } else {
                    fitnessHistory.prey.push({brain: this.brain.copy(), fitness: this.fitness});
                    if (fitnessHistory.prey.length > 20) fitnessHistory.prey.shift();
                }
                
                console.log(`${this.type} eliminated (${reason}): Fitness ${this.fitness.toFixed(1)}`);
            }

            calculateFinalFitness() {
                this.fitness = 0;
                
                if (this.type === 'HUNTER') {
                    this.fitness += this.totalTags * CONFIG.HUNTER_TAG_REWARD;
                    this.fitness += this.lifetimeFrames * CONFIG.HUNTER_SURVIVAL_REWARD;
                    this.fitness += this.totalDistance * 0.1;
                } else {
                    this.fitness += this.lifetimeFrames * CONFIG.PREY_SURVIVAL_REWARD;
                    this.fitness += this.totalTags * CONFIG.PREY_EVASION_REWARD; // Evasions
                    this.fitness += this.maxEnergyReached * 0.2;
                }
                
                if (this.isAlive) {
                    this.fitness += 100;
                }
                
                this.fitness = Math.max(0, this.fitness);
            }

            checkForTags() {
                if (!this.isAlive || this.tagCooldown > 0) return;
                
                for (let other of creatures) {
                    if (other !== this && other.isAlive) {
                        let distance = Math.sqrt(
                            Math.pow(this.x - other.x, 2) + 
                            Math.pow(this.y - other.y, 2)
                        );
                        
                        if (distance <= CONFIG.TAG_DISTANCE && 
                            this.type === 'HUNTER' && other.type === 'PREY') {
                            
                            // Evasion check
                            if (other.specialAbilities.evasion && 
                                other.abilityCooldowns.evasion === 0 && 
                                Math.random() < 0.3) {
                                other.energy -= 5;
                                other.abilityCooldowns.evasion = 45;
                                other.totalTags++; // Count evasion
                                console.log('Prey evaded!');
                                return;
                            }
                            
                            // Successful tag
                            this.totalTags++;
                            other.timesTagged++;
                            this.tagCooldown = 15;
                            
                            let energyGain = CONFIG.ENERGY_GAIN_TAG;
                            let energyLoss = CONFIG.ENERGY_GAIN_TAG * 0.5;
                            
                            if (this.specialAbilities.energyVampire) {
                                energyGain *= 1.5;
                                energyLoss *= 1.3;
                            }
                            
                            this.energy += energyGain;
                            this.maxEnergyReached = Math.max(this.maxEnergyReached, this.energy);
                            other.energy -= energyLoss;
                            
                            stats.totalTags++;
                            console.log(`Hunter tagged prey! Tags: ${this.totalTags}`);
                        }
                    }
                }
                
                if (this.tagCooldown > 0) this.tagCooldown--;
            }

            draw() {
                if (!this.isAlive) return;
                
                let pixelX = this.x * CONFIG.GRID_SIZE;
                let pixelY = this.y * CONFIG.GRID_SIZE;
                
                let color = CONFIG.COLORS[this.type];
                let alpha = Math.max(0.3, this.energy / CONFIG.STARTING_ENERGY);
                
                ctx.fillStyle = color;
                ctx.globalAlpha = alpha;
                
                ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                
                // Energy bar
                this.drawEnergyBar(pixelX, pixelY);
                
                // Camouflage effect
                if (this.specialAbilities.camouflage && this.abilityCooldowns.camouflage > 0) {
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(pixelX, pixelY, CONFIG.GRID_SIZE - 1, CONFIG.GRID_SIZE - 1);
                }
                
                // Ability indicators
                this.drawAbilityIndicators(pixelX, pixelY);
                
                ctx.globalAlpha = 1.0;
            }

            drawEnergyBar(x, y) {
                let barWidth = CONFIG.GRID_SIZE - 4;
                let barHeight = 3;
                let energyPercentage = Math.max(0, this.energy / CONFIG.STARTING_ENERGY);
                
                ctx.fillStyle = '#333333';
                ctx.globalAlpha = 0.8;
                ctx.fillRect(x + 2, y - 6, barWidth, barHeight);
                
                ctx.fillStyle = energyPercentage > 0.6 ? '#00ff00' : 
                               energyPercentage > 0.3 ? '#ffff00' : '#ff0000';
                ctx.fillRect(x + 2, y - 6, barWidth * energyPercentage, barHeight);
            }

            drawAbilityIndicators(x, y) {
                let size = 3;
                let offsetY = 0;
                
                if (this.specialAbilities.packHunting && this.type === 'HUNTER') {
                    ctx.fillStyle = '#ff8800';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(x + CONFIG.GRID_SIZE - 5, y + offsetY, size, size);
                    offsetY += 4;
                }
                
                if (this.specialAbilities.speedBurst && this.abilityUses.speedBurst > 0) {
                    ctx.fillStyle = '#ffff00';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(x + CONFIG.GRID_SIZE - 5, y + offsetY, size, size);
                }
            }
        }

        // ===== CONTINUOUS EVOLUTION FUNCTIONS =====
        
        function selectParentBrain(type) {
            let history = type === 'HUNTER' ? fitnessHistory.hunters : fitnessHistory.prey;
            
            if (history.length === 0) return null;
            
            history.sort((a, b) => b.fitness - a.fitness);
            let eliteCount = Math.ceil(history.length * CONFIG.ELITE_THRESHOLD);
            let selectedIndex = Math.floor(Math.random() * eliteCount);
            
            return history[selectedIndex].brain;
        }

        function processRespawns() {
            let hunterCount = creatures.filter(c => c.isAlive && c.type === 'HUNTER').length;
            let preyCount = creatures.filter(c => c.isAlive && c.type === 'PREY').length;
            
            for (let i = respawnQueue.length - 1; i >= 0; i--) {
                let respawn = respawnQueue[i];
                
                if (frameCount >= respawn.respawnFrame) {
                    let shouldSpawn = false;
                    
                    if (respawn.type === 'HUNTER' && hunterCount < CONFIG.MAX_HUNTERS) {
                        shouldSpawn = true;
                    } else if (respawn.type === 'PREY' && preyCount < CONFIG.MAX_PREY) {
                        shouldSpawn = true;
                    }
                    
                    if (shouldSpawn) {
                        let parentBrain = selectParentBrain(respawn.type);
                        let newCreature = new Creature(null, null, respawn.type, parentBrain);
                        
                        if (Math.random() < CONFIG.ABILITY_MUTATION_RATE) {
                            grantRandomAbility(newCreature);
                        }
                        
                        creatures.push(newCreature);
                        stats.totalRespawns++;
                        
                        if (respawn.type === 'HUNTER') hunterCount++;
                        else preyCount++;
                        
                        console.log(`Respawned ${respawn.type}`);
                    }
                    
                    respawnQueue.splice(i, 1);
                }
            }
        }

        function grantRandomAbility(creature) {
            let availableAbilities = [];
            
            if (creature.type === 'HUNTER') {
                availableAbilities = ['packHunting', 'energyVampire', 'speedBurst'];
            } else {
                availableAbilities = ['evasion', 'energyEfficiency', 'camouflage'];
            }
            
            availableAbilities.push('lethargy', 'anxiety');
            
            availableAbilities = availableAbilities.filter(ability => !creature.specialAbilities[ability]);
            
            if (availableAbilities.length > 0) {
                let chosen = availableAbilities[Math.floor(Math.random() * availableAbilities.length)];
                creature.specialAbilities[chosen] = true;
                console.log(`${creature.type} gained ${chosen}!`);
            }
        }

        function initializePopulation() {
            creatures = [];
            
            for (let i = 0; i < CONFIG.MAX_HUNTERS; i++) {
                let hunter = new Creature(null, null, 'HUNTER');
                if (Math.random() < 0.3) grantRandomAbility(hunter);
                creatures.push(hunter);
            }
            
            for (let i = 0; i < CONFIG.MAX_PREY; i++) {
                let prey = new Creature(null, null, 'PREY');
                if (Math.random() < 0.3) grantRandomAbility(prey);
                creatures.push(prey);
            }
            
            console.log(`Initialized: ${CONFIG.MAX_HUNTERS} hunters, ${CONFIG.MAX_PREY} prey`);
        }

        function updateStats() {
            let aliveCreatures = creatures.filter(c => c.isAlive);
            let hunters = aliveCreatures.filter(c => c.type === 'HUNTER');
            let prey = aliveCreatures.filter(c => c.type === 'PREY');
            
            stats.huntersAlive = hunters.length;
            stats.preyAlive = prey.length;
            
            if (hunters.length > 0) {
                hunters.forEach(h => h.calculateFinalFitness());
                stats.avgHunterFitness = hunters.reduce((sum, h) => sum + h.fitness, 0) / hunters.length;
                stats.bestHunterFitness = Math.max(...hunters.map(h => h.fitness));
            }
            
            if (prey.length > 0) {
                prey.forEach(p => p.calculateFinalFitness());
                stats.avgPreyFitness = prey.reduce((sum, p) => sum + p.fitness, 0) / prey.length;
                stats.bestPreyFitness = Math.max(...prey.map(p => p.fitness));
            }
        }

        // ===== GAME LOOP =====
        
        function update() {
            if (isPaused) return;
            
            frameCount++;
            
            for (let speed = 0; speed < simulationSpeed; speed++) {
                creatures.filter(c => c.isAlive).forEach(creature => {
                    creature.think();
                    creature.checkForTags();
                });
                
                processRespawns();
                
                if (frameCount % 30 === 0) {
                    updateStats();
                }
            }
        }

        function draw() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);
            
            walls.forEach(wall => wall.draw());
            creatures.filter(c => c.isAlive).forEach(creature => creature.draw());
            
            drawUI();
        }

        function drawUI() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Arial';
            ctx.globalAlpha = 0.8;
            
            let y = 30;
            let lineHeight = 25;
            
            ctx.fillText(`Hunters: ${stats.huntersAlive}/${CONFIG.MAX_HUNTERS}`, 20, y);
            y += lineHeight;
            ctx.fillText(`Prey: ${stats.preyAlive}/${CONFIG.MAX_PREY}`, 20, y);
            y += lineHeight;
            ctx.fillText(`Total Tags: ${stats.totalTags}`, 20, y);
            y += lineHeight;
            ctx.fillText(`Total Respawns: ${stats.totalRespawns}`, 20, y);
            y += lineHeight;
            ctx.fillText(`Avg Hunter Fitness: ${stats.avgHunterFitness.toFixed(1)}`, 20, y);
            y += lineHeight;
            ctx.fillText(`Best Hunter: ${stats.bestHunterFitness.toFixed(1)}`, 20, y);
            y += lineHeight;
            ctx.fillText(`Avg Prey Fitness: ${stats.avgPreyFitness.toFixed(1)}`, 20, y);
            y += lineHeight;
            ctx.fillText(`Best Prey: ${stats.bestPreyFitness.toFixed(1)}`, 20, y);
            y += lineHeight;
            ctx.fillText(`Speed: ${simulationSpeed.toFixed(1)}x`, 20, y);
            
            ctx.font = '12px Arial';
            ctx.fillText('Controls: SPACE=Pause, R=Reset, Arrow Keys=Speed', 20, CONFIG.CANVAS_HEIGHT - 40);
            
            ctx.globalAlpha = 1.0;
        }

        function createSpeedControl() {
            let container = document.createElement('div');
            container.style.position = 'fixed';
            container.style.top = '20px';
            container.style.right = '20px';
            container.style.background = 'rgba(0,0,0,0.7)';
            container.style.padding = '10px';
            container.style.borderRadius = '5px';
            container.style.color = 'white';
            container.style.fontFamily = 'Arial';
            container.style.fontSize = '14px';
            container.style.zIndex = '1000';
            
            let label = document.createElement('div');
            label.textContent = 'Simulation Speed';
            label.style.marginBottom = '5px';
            
            let slider = document.createElement('input');
            slider.type = 'range';
            slider.min = CONFIG.MIN_SIMULATION_SPEED;
            slider.max = CONFIG.MAX_SIMULATION_SPEED;
            slider.step = 0.1;
            slider.value = CONFIG.DEFAULT_SIMULATION_SPEED;
            slider.style.width = '150px';
            
            let valueDisplay = document.createElement('span');
            valueDisplay.textContent = `${CONFIG.DEFAULT_SIMULATION_SPEED.toFixed(1)}x`;
            valueDisplay.style.marginLeft = '10px';
            
            slider.addEventListener('input', function() {
                simulationSpeed = parseFloat(this.value);
                valueDisplay.textContent = `${simulationSpeed.toFixed(1)}x`;
            });
            
            container.appendChild(label);
            container.appendChild(slider);
            container.appendChild(valueDisplay);
            document.body.appendChild(container);
        }

        // ===== INITIALIZATION =====
        
        function init() {
            canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.id = 'gameCanvas';
                document.body.appendChild(canvas);
            }
            
            canvas.width = CONFIG.CANVAS_WIDTH;
            canvas.height = CONFIG.CANVAS_HEIGHT;
            ctx = canvas.getContext('2d');
            
            generateWalls();
            initializePopulation();
            createSpeedControl();
            setupEventListeners();
            
            console.log('Clean continuous evolution simulation initialized!');
        }

        function generateWalls() {
            walls = [];
            let gridWidth = CONFIG.CANVAS_WIDTH / CONFIG.GRID_SIZE;
            let gridHeight = CONFIG.CANVAS_HEIGHT / CONFIG.GRID_SIZE;
            let wallCount = Math.floor(gridWidth * gridHeight * CONFIG.WALL_DENSITY);
            
            for (let i = 0; i < wallCount; i++) {
                let x = Math.floor(Math.random() * gridWidth);
                let y = Math.floor(Math.random() * gridHeight);
                
                if (x > 0 && x < gridWidth - 1 && y > 0 && y < gridHeight - 1) {
                    walls.push(new Wall(x, y));
                }
            }
        }

        function setupEventListeners() {
            document.addEventListener('keydown', function(event) {
                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        isPaused = !isPaused;
                        console.log(isPaused ? 'Paused' : 'Resumed');
                        break;
                    case 'KeyR':
                        resetSimulation();
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        simulationSpeed = Math.min(CONFIG.MAX_SIMULATION_SPEED, simulationSpeed + 0.5);
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        simulationSpeed = Math.max(CONFIG.MIN_SIMULATION_SPEED, simulationSpeed - 0.5);
                        break;
                }
            });
            
            window.addEventListener('resize', function() {
                CONFIG.CANVAS_WIDTH = window.innerWidth;
                CONFIG.CANVAS_HEIGHT = window.innerHeight;
                canvas.width = CONFIG.CANVAS_WIDTH;
                canvas.height = CONFIG.CANVAS_HEIGHT;
            });
        }

        function resetSimulation() {
            frameCount = 0;
            creatures = [];
            respawnQueue = [];
            fitnessHistory = { hunters: [], prey: [] };
            totalCreaturesSpawned = 0;
            stats = {
                huntersAlive: 0,
                preyAlive: 0,
                totalTags: 0,
                totalRespawns: 0,
                avgHunterFitness: 0,
                avgPreyFitness: 0,
                bestHunterFitness: 0,
                bestPreyFitness: 0
            };
            
            generateWalls();
            initializePopulation();
            console.log('Simulation reset!');
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start simulation
        window.addEventListener('load', function() {
            init();
            gameLoop();
        });
    </script>
</body>
</html>
